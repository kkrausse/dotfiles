:PROPERTIES:
:header-args: :results silent
:END:
#+TITLE: Doom Emacs Config

this setup was taken from [[https://www.youtube.com/watch?v=SzA2YODtgK4&ab_channel=thoughtbot][this video]] and the [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][setup he uses]].

notes:
- direction is to prefer `map!`, `after!`, and `add-hook!` as opposed to extensive
   `use-package` commands

* initial setup / utils

#+begin_src elisp
;; -*- lexical-binding: t; -*-
(load "~/.doom.d/machine-specific.el")

(defmacro kev/comment (&rest args)
  nil)

;; I'm *pretty sure* this helps goto find the doom specific functions
(setq find-library-source-path
      (append load-path
              (list
               (expand-file-name "lisp" "~/.config/emacs")
               (expand-file-name "lisp/lib" "~/.config/emacs"))))

;; finer grained font size control
(setq doom-font-increment 1
      use-package-always-defer 't
      use-package-compute-statistics 't)

;; c source directory
;; `git clone --branch emacs-28.2 --depth 1 https://github.com/emacs-mirror/emacs repos/emacs`
(setq find-function-C-source-directory "~/.doom.d/repos/emacs/src")



(add-hook 'shell-mode-hook (lambda ()
                             (company-mode -1)))

;; DONT add regex search to the jump stack!
(evil-set-command-property 'evil-ex-search-next :jump nil)
(evil-set-command-property 'evil-ex-search-backward :jump nil)

;; company mode setup

(after! company
  ;; TODO why do I need this?
  ;; something wrong with the config I think
  (global-company-mode -1)

  (add-hook! 'org-mode-hook
    (setq company-idle-delay 0.9))

  (setq company-idle-delay 0.5)
  (company-mode-on)
  (setq company-minimum-prefix-length 1
        company-dabbrev-minimum-length 2
        company-dabbrev-ignore-case 'keep-prefix
        company-dabbrev-other-buffers t)
  ;; I don't want tab to cycle
  (map! :map company-active-map
        "<tab>" #'company-complete)
  )

;; diplay buffer stuff
(setq display-buffer-base-action '((display-buffer-reuse-window
                                    display-buffer-same-window
                                    display-buffer-use-least-recent-window) . nil))
;; example to set alternames based on buffer name,
;; (setf (alist-get "\\*cider-repl.*" display-buffer-alist)
;;       '(display-buffer-use-least-recent-window))


;; multi term stuff , which I don't use anymore really
(setq multi-term-program "/bin/zsh")
(setq-default explicit-shell-file-name "/bin/zsh")
(setq multi-term-switch-after-close nil)


;; I think needed for env vars in the shell?
;; might actuall not be
(use-package! exec-path-from-shell :defer t)
(after! exec-path-from-shell
  (dolist (var '("JAVA_HOME"))
    (add-to-list 'exec-path-from-shell-variables var))
  (exec-path-from-shell-initialize))
#+end_src

* UI preferences
** Theme
#+begin_src elisp
;; theme shite

;; see https://www.ditig.com/256-colors-cheat-sheet for colors! should just do 256 tbh so
;; also, maybe can look at default doom themes for some guidance

;; my custom shit
;; (setq doom-customize-theme-hook nil)
(load-theme 'my-vibrant t)
(setq doom-theme 'my-vibrant)

;;(setq doom-theme 'doom-vibrant)
;; TODO:
;; doom-vibrant, but port over my changes to just the hook
;; doom-one is default and ssems like it would have most support for doom-specific things but it's is super low contrast so I think I need to like overlay the solarized colors on the featuresset of doom-one
;; note: that it is the default also means it would be overly configurable and gross to work with
;; also note: I started with vibrant but changed literally everything. It's not the same theme anymore at all.

;; doom-solarized-dark
;; doom-solarized-dark-high-contrast
;; doom-molokai

;; is good, but it's annoying because you don't rely completely on your theme
;; but this must be set first since things rely on this I guess
;; (custom-set-faces! `(default :background ,(doom-color 'bg)))
#+end_src

** Modeline

doom-modeline package for [[https://github.com/seagle0128/doom-modeline][dopeness]]

#+begin_src elisp :results silent
(after! doom-modeline
  (doom-modeline-mode 1)
  (setq doom-modeline-percent-position nil
        doom-modeline-height 1)

  (column-number-mode 1)
  ;; compare to https://github.com/seagle0128/doom-modeline/blob/e521d32c2d670dc664424857e3fc18a37f0728f6/doom-modeline.el#L90
  ;; also, look through

;; original
;; (doom-modeline-def-modeline 'main
;; '(eldoc bar workspace-name window-number modals matches follow buffer-info remote-host buffer-position word-count parrot selection-info)
;; '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs checker time))

  ;; look
  ;; got rid of lsp, modals, repl, buffer-encoding, major-mode, checker
  (doom-modeline-def-modeline 'kev-main-modeline
      '(eldoc bar workspace-name window-number matches follow buffer-info remote-host buffer-position word-count parrot selection-info)
      '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus github debug lsp minor-modes input-method indent-info process vcs))

  (add-hook! 'doom-modeline-mode-hook
    (doom-modeline-set-modeline 'kev-main-modeline 'default))
  )
#+end_src


and make multi-term use it

#+begin_src elisp
(add-hook! term-mode-hook
           'doom-modeline-mode)
#+end_src
* My Plugins
** ellama
#+begin_src elisp
;; NOTE will eval NOW if package already loaded
(after! ellama
  (setq
   ellama-provider (make-llm-ollama
                    :scheme "http"
                    :host "localhost"
                    :port 11434
                    :chat-model "zephyr"
                    :embedding-model "zephyr")))
#+end_src

** gpt
#+begin_src elisp


(defun surrounding-fn-bounds ()
  (cond
   ((eq major-mode 'clojure-mode) (cider-defun-at-point 'bounds))
   ((eq major-mode 'emacs-lisp-mode) (let (beg end)
                                       (save-excursion
                                         (end-of-defun)
                                         (beginning-of-defun)
                                         (setq beg (point))
                                         (end-of-defun)
                                         (setq end (point)))
                                       (list beg end)))
   ('t nil)))


(defun other-window ()
  "gets the window that is not the current one"
  (car (seq-filter (lambda (w) (not (eq (get-buffer-window) w)))
                   (window-list))))

;; TODO make this read from env var.
(defvar openai-api-key-1 "***")

(defun double-escape-string (s)
  (thread-last s
               (s-replace "\"" "\\\"")
               (s-replace "\n" "\\n")))

(defun atom-replace (old new tree)
  (if (atom tree)
      (if (eq old tree)
          new
        tree)
    (cons (atom-replace old new (car tree)) (atom-replace old new (cdr tree)))))

(defmacro thread$ (head &rest forms)
  (if (car forms)
      `(athread ,(atom-replace '$ head (car forms)) ,@(cdr forms))
    head))

(defun read-resp-buffer (b)
  (with-current-buffer b
    (goto-char (point-min))
    (re-search-forward "^$")
    (thread$ (json-read)
             (alist-get 'choices $)
             (aref $ 0)
             (alist-get 'text $))))

(defvar test-resp)

(cl-defun make-openai-request (&key url data handle)
  "makes an http request to the openai edit api to the davinci code model and passes
in `input' to get back edits made by the model"
  (let* ((url-request-method "POST")
         (url-request-data data)
         (url-request-extra-headers
          `(("Content-Type" . "application/json")
            ("Authorization" . ,(concat "Bearer " openai-api-key-1))))
         (_ (message (format "calling: %s with data: %s" url data)))
         (resp (url-retrieve-synchronously url)))
    (setq test-resp resp)
    (funcall handle resp)))


;; (progn test-resp)
;; (with-current-buffer test-resp
;;   (buffer-string))

;; (read-resp-buffer test-resp)

(defun code-davinci-edit-data (input)
  `(:url "https://api.openai.com/v1/edits"
    ;     "http://localhost:8000"
    :data
    ,(json-encode
      `((model . "code-davinci-edit-001")
        (input . ,input)
        (instruction .
         "Add code to the body of the function so it completes the documented task as simply as possible")
        (temperature . 0)
        (top_p . 1)))
    :handle ,(lambda (resp) (read-resp-buffer resp))))

(defun code-davinci-insert-data (input &optional separator)
  (unless separator
    (setq separator "\\[insert\\]"))
  (cl-destructuring-bind (pre post) (s-split separator input)
    (unless (and pre post)
      (throw 'input-error (format "need separater '%s'" separator)))
    `(:url "https://api.openai.com/v1/completions"
      :data
      ,(json-encode
        `((model . "code-davinci-002")
          (prompt . ,pre)
          (suffix . ,post)
          (temperature . 0)
          (max_tokens . 512)
          (top_p . 1)
          (frequency_penalty . 0.3)
          (presence_penalty . 0)))
      :handle (lambda (resp)
                (let ((insert (read-resp-buffer resp)))
                  (concat ,pre insert ,post))))))

(defun test-region (start end)
  (interactive "r")
  (print
   (list start end (buffer-substring-no-properties start end))))

(defun gpt-edit-2 ()
  (interactive)
  (let ((bounds (if (region-active-p)
                    (list (region-beginning) (region-end))
                  (surrounding-fn-bounds))))
    (unless bounds
      (message "unable to get fn bounds. Language not supported?"))
    (when bounds
      (replace-region-contents
       (car bounds)
       (cadr bounds)
       (lambda ()
         (thread$ bounds
                  (apply 'buffer-substring-no-properties $)
                  (code-davinci-insert-data $)
                  (apply 'make-openai-request $)))))))

#+end_src
** kevin paredit!

#+begin_src elisp
(define-minor-mode kevin-paredit-mode
  "lisp state for paredit"
  :lighter " kevin paredit"
  (setq evil-move-beyond-eol kevin-paredit-mode))

(defmacro kevin/sp-kill-movement-fn (name &rest body)
  `(defalias (intern (concat "kevin/kill-to-"
                             (symbol-name (quote ,name))))
     (lambda ()
       (interactive)
       (let ((p (point)))
         ,@body
         (sp-kill-region p (point))))))

(evil-define-minor-mode-key
  '(normal visual) 'kevin-paredit-mode
  "B" 'sp-backward-barf-sexp
  "b" 'sp-forward-barf-sexp
  "s" 'sp-forward-slurp-sexp
  "S" 'sp-backward-slurp-sexp
  "t" 'sp-transpose-sexp
  "f" (lambda ()
        (interactive)
        (print (list "use region" (use-region-p)))
        (if (use-region-p)
            (let ((m (mark))
                  (s (region-beginning)))
              (clojure-align (region-beginning) (region-end))
              (lsp-format-region (region-beginning) (region-end))
              ;; (print (list "region:" (region-beginning) (region-end)
              ;;              (region-active-p)))
              )
          (progn
            (sp-mark-sexp)
            (clojure-align (region-beginning) (region-end))
            (lsp-format-region (region-beginning) (region-end))
            (pop-mark))))
  ;; parens
  "[" 'sp-wrap-square
  "{" 'sp-wrap-curly
  "w" 'sp-wrap-round
  "W" 'sp-unwrap-sexp
  "m" 'sp-mark-sexp

  ;; killing
  "da" 'sp-splice-sexp-killing-around
  "d$" (kevin/sp-kill-movement-fn
        end-of-sexp
        (sp-end-of-sexp))
  "d0" (kevin/sp-kill-movement-fn
        beginning-of-sexp
        (sp-beginning-of-sexp))
  "dl" (kevin/sp-kill-movement-fn
        next-sexp
        (sp-forward-sexp))
  "dh" (kevin/sp-kill-movement-fn
        beginning-of-sexp
        (sp-backward-sexp))

  ;; movement
  "h" 'sp-backward-sexp
  "H" 'sp-backward-down-sexp
  "l" 'sp-forward-sexp
  "L" 'sp-down-sexp
  "j" 'sp-down-sexp
  "k" 'sp-backward-up-sexp
  "." 'kevin-paredit-mode
  (kbd "<escape>") 'kevin-paredit-mode)

(general-define-key
 :states '(normal visual)
 :keymaps 'global
 :prefix "SPC"
 "k" 'kevin-paredit-mode)
#+end_src

* General Setup
** utility functions
#+begin_src elisp
(defmacro kev-setq-local (&rest kvs)
  `(progn
     ,@(mapcar
        (lambda (pair)
          (cl-destructuring-bind (sym val) pair
            `(progn
               (make-local-variable ',sym)
               (setq ,sym ,val))))
        (seq-partition kvs 2))))

(defmacro kev-fn (arglist &rest body)
  (let ((fargsym (gensym "arg")))
    `(lambda (,fargsym)
       (cl-destructuring-bind ,arglist
           ,fargsym
         ,@body))))

;; just realized this isn't even needed because the builtin
;; browse at remote already handles this exact situation
(defun kev-get-commit (beg end)
  (interactive "r")
  (require 'browse-at-remote)
  (let* ((commit (string-trim (buffer-substring beg end))) ;; was using (current-kill 0), but annoying
         (url
          (browse-at-remote--commit-url commit)))
    (kill-new url)
    (message (concat "copied: " url))))

(defun kev-project-ignored-p (root)
  (or (doom-project-ignored-p root)
      (string-match-p "/node_modules/" root)
      (string-match-p "/.cache/" root)
      (string-match-p "/.gitlibs/" root)))

(setq projectile-ignored-project-function 'kev-project-ignored-p)

;; evil-beginning-of-line
;; newline-and-indent
;; evil-next-line
;; FIXME the problem is that the value of end-point is no longer valid because (indent-according-to-mode) changes the buffer!
(defun kev-indent (beg end)
  "indents highlighted."
  (interactive "r")
  (save-excursion
    (let ((end-line (line-number-at-pos (- end 1))))
      (goto-char beg)
      (indent-according-to-mode)
      ;; such as a way to do the last line, but never try to go past it
      (while (< (line-number-at-pos)
                end-line)
        (evil-next-line)
        (indent-according-to-mode)))))

(defun projectile-term ()
  "if terminal exists in project, switch to it. else, create at project root"
  (interactive)
  (let ((term-buf (seq-some (lambda (b)
                              (with-current-buffer b
                                (and (derived-mode-p 'vterm-mode) b)))
                            (projectile-project-buffers))))
    (if term-buf
        (switch-to-buffer term-buf)
      (progn
        ;; no need to open in root bc vterm here does that!
        ;;(find-file (projectile-project-root))
        (+vterm/here nil)))))

(defun get-displayed-buffer (pred)
  (seq-some (lambda (w) (with-current-buffer (window-buffer w)
                        (and (funcall pred)
                             (window-buffer w))))
          (window-list)))

(defun call-previous-term-cmd ()
  (interactive)
  (with-current-buffer (get-displayed-buffer (lambda () (eq 'term-mode major-mode)))
    (term-send-up)
    (term-send-return)))

;; just map everywhere
(map!
 (:prefix ("SPC j" . "kevin stuff")
          :nv  "i" 'kev-indent
          :nv "t" 'projectile-term
          :nv "pp" 'jet-to-clipboard
          :nv "pt" 'call-previous-term-cmd
          (:prefix ("e" . "edit")
                   :n "e" 'edit-env-file
                   :n "c" 'doom-edit-config
                   :n "t" '(lambda () (interactive) (find-file "~/dotfiles/tmp.org")))))


;; (-> 'display-buffer-alist
;;         (add-to-list '(".*magit.*"
;;                        (display-buffer-reuse-window display-buffer-same-window))))

(add-hook! magit-mode
  (map!
   (:prefix ("SPC j" . "kevin stuff")
            :map magit-section-mode-map
            :nv "c" 'kev-get-commit)))


;; this is actually great http://clhs.lisp.se/Body/03_dd.htm
;; aslo the cl-defmacro definition has some of that info

;; requires a (require 'straight) call. so quote it for now

(defun kev-list-packages ()
  (interactive)
  (mapcar (kev-fn (build-time deps (&whole whole &key type package &allow-other-keys))
                  (print (list :pack package
                               :buildt build-time
                               :type type)))
          (hash-table-values straight--build-cache)))

;; stolen from borkdude: https://github.https://github.com/borkdude/prelude/blob/master/personal/init.el#L195om/borkdude/prelude/blob/master/personal/init.el#L195
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

** Keybindings
#+begin_src elisp
;; sets comma as spc m
(setq evil-snipe-override-evil-repeat-keys nil)
(setq doom-localleader-key ",")

;; vinegar
(define-key evil-normal-state-map (kbd "-") 'dired-jump)

;; for evil-escape package
;; so much better than key chord!!
(setq-default evil-escape-key-sequence "jj")
(setq-default evil-escape-delay 0.2)

#+end_src

** Random Config
#+begin_src elisp
(setq projectile-switch-project-action #'projectile-dired)

;; makes the above thing actially work
(setq counsel-projectile-switch-project-action (lambda (project)
                                                 (dired (projectile-project-root project))))

;; delete dired buffers when switching
(define-advice dired-find-file (:around (orig-fun &rest _) dired-find-file-advice)
  (let ((prev-buf (current-buffer)))
    (funcall-interactively orig-fun)
    (when (and (eq 'dired-mode (buffer-local-value 'major-mode prev-buf))
               ;; ONLY FOR dired buffer! Leave it if we go to a file?
               (eq 'dired-mode (buffer-local-value 'major-mode (current-buffer)))
               ;; make sure it's not currently displayed
               (not (seq-find (lambda (w)
                                (eq prev-buf
                                    (window-buffer w)))
                              (window-list)))
               (not (eq prev-buf (current-buffer))))
      (kill-buffer prev-buf))))

(define-advice dired-up-directory (:around (orig-fun &rest args) dired-up-advice)
  (let ((prev-buf (current-buffer)))
    (apply #'funcall-interactively orig-fun args)
    (when (and (eq 'dired-mode (buffer-local-value 'major-mode prev-buf))
               ;; make sure it's not currently displayed
               (not (seq-find (lambda (w)
                                (eq prev-buf
                                    (window-buffer w)))
                              (window-list)))
               (not (eq prev-buf (current-buffer))))
      (kill-buffer prev-buf))))




;; github yank line link
;; (setq browse-at-remote-remote-type-domains
;;       (cons '("github.dev.pages" . "github") browse-at-remote-remote-type-domains))
;; dont prompt on exit
(setq confirm-kill-emacs nil)
;; when exit insert mode exit
(setq evil-move-cursor-back t)

;; flycheck has horrible perf.. maybe?
(setq flycheck-check-syntax-automatically '(save idle-change))
(setq flycheck-disabled-checkers '(emacs-lisp-checkdoc))

#+end_src

line numbers

#+begin_src elisp
;; so we *can* display line numbers, but need to disable it for various
;; modes we don't want by default
(setq display-line-numbers-type t)
(remove-hook! '(prog-mode-hook text-mode-hook conf-mode-hook)
  #'display-line-numbers-mode)
#+end_src
** perf fixes
#+begin_src elisp
(defmacro timed-cached-funcall (time fn)
  (let ((last-time (gensym "last-time"))
        (cached-val (gensym "cached-val"))
        (fn-args (gensym "fn-args")))
    `(let ((,last-time -100.0)
           (,cached-val nil))
       (lambda (&rest ,fn-args)
         (when (> (- (float-time) ,last-time) ,time)
           (setq ,last-time (float-time))
           (setq ,cached-val (apply (quote ,fn) ,fn-args)))
         ,cached-val))))

;; this IS necessary. fuckin shit is slow without it
;; (setq kevin-project-root "johnson")
;; (setq kevin-project-root-timer
;;       (run-with-idle-timer 1 t (lambda () (setq kevin-project-root (projectile-project-root)))))
(setq kev-cached-project-root (timed-cached-funcall 1.0 projectile-project-name))

(setq frame-title-format '((:eval
                            (funcall kev-cached-project-root))))

;; noticed bad perf here
(setq kev-cached-modeline-buffer-file-state
      (timed-cached-funcall 1.0 doom-modeline-update-buffer-file-state-icon))

(define-advice doom-modeline-update-buffer-file-state-icon
    (:around (orig-fun &rest _) doom-modeline-advice)
  (funcall kev-cached-modeline-buffer-file-state))
#+end_src

** Project management
*** git
#+begin_src elisp
(use-package! browse-at-remote
  :config
  (print (list "regexps: " browse-at-remote-remote-type-regexps))
  (add-to-list 'browse-at-remote-remote-type-regexps
               '(:host "github.dev.pages$" :type "github"))
  )
#+end_src

* Lang
** org babel
#+begin_src elisp
;; org babel stuff
(after! org
  (require 'ob-clojure)
  (setq org-babel-clojure-backend 'cider)

  (add-to-list 'org-babel-default-header-args
             '(python . (:results . "output"))))

(defvar-local kev-cider-session nil)

(defun kev/select-option (prompt alist)
  (require 'ivy)
  (cdr
   (assoc (ivy-read prompt alist :require-match t)
          alist)))

(defun kev/select-session ()
  (require 'ivy)
  (let* ((sessions (cider-sessions))
         (_ (unless sessions (error "no repl sessions found! start one first")))
         (session (if (member kev-cider-session sessions)
                      kev-cider-session
                    (setq kev-cider-session
                          (if (cdr sessions)
                              (kev/select-option
                               "pick session: "
                               (seq-map
                                (lambda (sesh)
                                  (cons (buffer-name (cadr sesh))
                                        (cadr sesh)))
                                sessions))
                            (setq kev-cider-session (cadar sessions)))))))
    session))

(after! ob-clojure
  (defun org-babel-execute:clojure (body params)
    "Execute a block of Clojure code with Babel and nREPL."
    (require 'cider)

    (setq kev-cider-session nil)

    (let* ((session (kev/select-session))
           (response (cider-nrepl-sync-request:eval
                      (org-babel-expand-body:clojure body params)
                      session)))
      (nrepl-dbind-response response (out status)
        (print
         (list "cider session:" session
               "params:" params
               "result" response))
        out))))
#+end_src

** org
#+begin_src elisp
(after! org
  ;;(define-key org-mode-map (kbd "C-c f") #'org-babel-execute-src-block)

;; Including =org-tempo= restores the =<s=-style easy-templates that were
;; deprecated in Org 9.2.
  (require 'org-tempo)

  ;; start everything folded
  (setq org-startup-folded 't)
;; code blocks font
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t))

(defun is-file-in-subdirectory (subdir)
  "Check if the current buffer's file is in a specified SUBDIR."
  (let ((current-file (buffer-file-name)))
    (when current-file
      (string-prefix-p (expand-file-name subdir)
                       (expand-file-name current-file)))))

;; general org settings
(after! org
  (map! :map evil-org-mode-map
        :m "C-k" #'evil-previous-visual-line
        :m "C-j" #'evil-next-visual-line
        :m "gj" #'evil-next-visual-line
        :m "gk" #'evil-previous-visual-line
        :localleader
        "'"  #'org-edit-special
        (:prefix "g" "b" #'org-mark-ring-goto)))

(defun kev-set-visual-columns ()
  (visual-line-mode 1)
  (visual-fill-column-mode 1)
  (after! visual-fill-column
    (setq visual-fill-column-width 80
          ;; idk if I like this yet
          visual-fill-column-center-text nil)))

(add-hook! 'org-mode-hook :append
           ;; org roam should fix column width!
  (after! org-roam
    (when (is-file-in-subdirectory org-roam-directory)
      (kev-set-visual-columns))))

;; makes a clearer distinction between sub-bullets
(use-package! org-bullets-mode
  :hook org-mode)
#+end_src

wat?

#+begin_src elisp
(defun kev/org-archive-subtree
  (org-copy-subtree))
#+end_src

** org-roam

org-roam setup and shortcuts

- subnode extention
  - problem statement: explosion of one flat directory is untenable especially when you want to look for something within a specific directory. Still want to preserve roam's ultimate freedom and linking though.
  - implementation
    - ONLY thing added is the property =:SUBNODE_OF: <org_id>= which will mark subnodes and find those to search & exclude them from regular search, exept by parent.
    - parents are found by just finding all ids that appear in a :subnode_of:
    - have to change regular finds to ignore subnodes now
  - TODO
    - allow for multiple subnode_of entries so you can "file" something under two things??
    - make roam buffer section for subnodes

#+begin_src elisp
;; -*- lexical-binding: t; -*-

(defun kev/complement (fn)
  (lambda (&rest args)
    (not (apply 'funcall fn args))))

(defun kev/roam-subnode-get-parent (node)
  (thread-last node
               (org-roam-node-properties)
               (assoc-string "SUBNODE_OF")
               (cdr)
               (org-roam-node-from-id)))

(defun kev/roam-subnode-get-parent-ids ()
  (seq-reduce
   (lambda (ids node)
     (let ((subnode-of (thread-last node
                                    (org-roam-node-properties)
                                    (assoc-string "SUBNODE_OF")
                                    (cdr))))
       (if (and subnode-of
                (not (member subnode-of ids)))
           (cons subnode-of ids)
         ids)))
   (org-roam-node-list)
   nil))

(defun kev/roam-subnode-find-parent ()
  (let ((parent-ids (kev/roam-subnode-get-parent-ids)))
    (org-roam-node-read nil
                        (lambda (node)
                           (member (org-roam-node-id node) parent-ids))
                        nil
                        'require-match
                        "parend node: ")))

(defun kev/roam-subnode-filter-subnodes (parent-node)
  (lambda (fnode)
     (thread-last
       fnode
       (org-roam-node-properties)
       (assoc-string "SUBNODE_OF")
       (cdr)
       (s-equals? (org-roam-node-id parent-node)))))

;;;;;;;;;;;;;;;; main interface ;;;;;;;;;;;;;;;

(defun kev/roam-subnode-create ()
  (interactive)
  (let ((parent (org-roam-node-read nil
                                    ;; I have subnodes of subnodes so I can't do this lol
                                    nil ;;(kev/complement #'kev/roam-subnode-get-parent)
                                    nil
                                    'require-match "parent node: ")))
    (org-id-get-create)
    (org-roam-add-property (org-roam-node-id parent) "SUBNODE_OF")
    ;; subnode of title purely for visibility, not used for anything
    (org-roam-add-property (org-roam-node-title parent) "SUBNODE_OF_TITLE")))

(defun kev/roam-subnode-find ()
  (interactive)
  (require 'org-roam-node)
  (let ((pnode (kev/roam-subnode-find-parent)))
    (org-roam-node-visit
     (org-roam-node-read nil
                         (kev/roam-subnode-filter-subnodes pnode)
                         nil
                         'require-match))))

(defun kev/roam-subnode-insert ()
  (interactive)
  (let ((pnode (kev/roam-subnode-find-parent)))
    (org-roam-node-insert (kev/roam-subnode-filter-subnodes pnode))))

(defun kev/roam-subnode-find-non-subnodes ()
  (interactive)
  (funcall #'org-roam-node-find nil nil (kev/complement #'kev/roam-subnode-get-parent)))




;;;;;;;;;;;;;;;;;;;;;;; main roam config ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO do the file resize thing and visual line mode
;; to org roam dir
;; org roam to display in same window
(add-to-list 'display-buffer-alist '("\\*org-roam.*\\*" . (display-buffer-reuse-window display-buffer-same-window)))
(add-to-list 'display-buffer-alist '("\\*lsp-help\\*" . (display-buffer-reuse-window display-buffer-same-window)))


;; map org roam everywhere to these autoloads
(map! (:prefix ("C-c n" . "Org Roam")
               (:prefix ("s" . "sub-node")
                        "i" #'kev/roam-subnode-insert
                        "c" #'kev/roam-subnode-create
                        "f" #'kev/roam-subnode-find)
               ;; "f" #'org-roam-node-find
               "f" (cons "find node" #'kev/roam-subnode-find-non-subnodes)
               "d" #'org-roam-dailies-find-directory))

(after! org-roam

  (map! (:map org-mode-map
              (:prefix ("C-c n" . "Org Roam")
                       (:prefix ("s" . "sub-node")
                                "i" #'kev/roam-subnode-insert
                                "c" #'kev/roam-subnode-create
                                "f" #'kev/roam-subnode-find)
                       "c" #'org-id-get-create
                       "i" (cons "insert node link"
                                 '(lambda ()
                                   (interactive)
                                   (funcall #'org-roam-node-insert (kev/complement #'kev/roam-subnode-get-parent)))
                                 )
                       "r" '("org-roam-buffer-display-dedicated" .
                             (lambda ()
                               (interactive)
                               ;; sets up prefix arg so it uses current node
                               ;; number `1' is not specific here
                               (setq current-prefix-arg '(1))
                               (call-interactively #'org-roam-buffer-display-dedicated)))
                       "d" #'org-roam-db-sync
                       "a" #'org-roam-alias-add)))

  ;; makes it so you can see if something is a subnode
  ;; probably not needed anymore.
  (cl-defmethod org-roam-node-kev-subnode-format ((node org-roam-node))
    (let ((parent-node (thread-last node
                                    (org-roam-node-properties)
                                    (assoc-string "SUBNODE_OF")
                                    (cdr)
                                    (org-roam-node-from-id))))
      (if parent-node
          (concat (org-roam-node-kev-subnode-format parent-node) " -> " (org-roam-node-title node))
        (org-roam-node-title node))))
  (setq org-roam-node-display-template "${kev-subnode-format}")

  (setq org-roam-dailies-directory "daily/")
  ;; If you're using a vertical completion framework, you might want a more informative completion interface
  ;; (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  (org-roam-db-autosync-mode 1)

  ;; TODO: make this only go up a few levels of indentation rather than to zero.
  ;; should be pretty easy
  (defun kev/org-roam-preview ()
    "default is `org-roam-preview-default-function' This changes to just line"
    (let* ((start-indent (current-indentation))
           (beg (save-excursion
                  (while (not (or (= 0 (current-indentation))
                                  ;; go up two levels of indent
                                  (<= (current-indentation) (- start-indent 3))))
                   (evil-previous-line))
                 (beginning-of-line)
                 (point)))
          (end (save-excursion
                 ;; so it collects heading stuff. Maybe should remove
                 (if (= ?* (char-after (line-beginning-position)))
                     (org-end-of-subtree)
                   (progn
                     (evil-next-line)
                     (while (not (or (<= (current-indentation) start-indent)
                                     (<= (point-max) (line-end-position))))
                       (evil-next-line))
                     (evil-beginning-of-line)))
                 (point))))
      (string-trim (concat (buffer-substring-no-properties beg end) "\n"))))

  ;; makes roam stuff prettier
  (add-hook! 'org-roam-mode-hook
    (kev-set-visual-columns))

  ;; define some keys everywhere
  (setq org-roam-v2-ack t
        org-roam-preview-function #'kev/org-roam-preview)

  )

(use-package! org-roam
  :after org
  ;; this would load it during idle time
  ;; :defer-incrementally org
  ;; :commands (org-roam-node-find org-roam-node-insert)
  )
#+end_src

** rust

#+begin_src elisp
(use-package! yasnippet
  :hook ((lsp-mode . yas-minor-mode)))

;; (rustic-cargo-current-test)

(add-hook! rustic-mode
  (lsp)
  (lsp-mode 1)
  (yas-minor-mode 1)
  (read-only-mode 0)
  :local
  (kev-setq-local
   lsp-rust-analyzer-display-lifetime-elision-hints-enable "always"
        lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t
        lsp-headerline-breadcrumb-enable nil
        lsp-ui-sideline-enable t
        lsp-ui-sideline-show-code-actions t
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-hover t
        lsp-signature-auto-activate t
        lsp-signature-render-documentation t
        lsp-ui-doc-enable nil
        lsp-ui-doc-show-with-cursor nil
        lsp-ui-doc-position 'at-point

        lsp-completion-show-detail t
        lsp-completion-show-kind t
        rustic-default-test-arguments "--benches --tests --all-features --nocapture")

  ;; TODO make local to rust mode
  (map! :map lsp-command-map
        "t"  #'lsp-rust-analyzer-related-tests
        "dd" #'lsp-rust-analyzer-open-external-docs))
#+end_src

#+RESULTS:

** elisp

#+begin_src elisp
;; gotos
(use-package! elisp-slime-nav
  :defer-incrementally (elisp-mode ielm))

(add-hook! (emacs-lisp-mode ielm-mode)
    (turn-on-elisp-slime-nav-mode)
    (map! :mode emacs-lisp-mode
          :localleader
          "gg" #'elisp-slime-nav-find-elisp-thing-at-point
          "gb" #'pop-tag-mark))
#+end_src
** Ruby
#+begin_src elisp
(map! :mode ruby-mode
      :localleader
      :prefix ("g". "goto")
      "g" #'robe-jump
      :prefix ("e" . "eval..")
      "b" #'ruby-send-buffer
      "d" #'ruby-send-definition
      "f" #'ruby-send-block
      "e" #'ruby-send-last-stmt
      "r" #'ruby-send-region)

(remove-hook 'robe-mode-hook 'ac-robe-setup)

(eval-after-load 'company
  '(push 'company-robe company-backends))
#+end_src

#+RESULTS:

** JavaScript n TypeScript

#+begin_src elisp
;; lsp uses typescript-language-server
;; with npm i -g typescript-language-server
(add-hook! typescript-mode
  (lsp)
  (lsp-mode 1)

  (setq typescript-indent-level 2))
#+end_src

#+RESULTS:

update: should really just use emacs' lsp-mode for this

#+begin_src elisp
(add-hook! js2-mode
           (lsp)
           (lsp-mode 1))

(map! :mode js2-mode
      :localleader
      (:prefix ("g" . "goto...")
      "g" 'js2-jump-to-definition
      "b" #'pop-tag-mark))

#+end_src

for skewer, like a repl type thing for js

#+begin_src elisp

(map! :mode skewer
      (:prefix (",e" . "skewer eval")
       "d" 'skewer-eval-defun))

#+end_src

#+RESULTS:

** python
#+begin_src elisp

(defvar kev-remote-shell-interpreter "/home/kkrausse/bin/conda_python.sh"
  "no spaces allowed! a restriction of python.el")

;; NOTE: may have to look back into run-python to see if I need to enable remote local variables or something
(defun kev/python-remote-shell ()
  (interactive)
    (with-current-buffer (find-file-noselect "/ssh:kkrausse@diesel2:/home/kkrausse/repos/kkrausse/memory-mistral")
      (with-connection-local-variables
       (print (list "current buffer " (current-buffer)
                    (find-file-noselect "/ssh:kkrausse@diesel2:/home/kkrausse/repos/kkrausse/memory-mistral")
                    (pwd)))
       (run-python kev-remote-shell-interpreter))))

(defun kev/python-shell-send-toplevel ()
  (interactive)
  (let ((start (point)))
    (save-excursion
      (python-shell-send-region
       (progn (end-of-line)
              (while (> (current-indentation) 0)
                (python-nav-backward-statement))
              (beginning-of-line)
              (point-marker))
       (progn (goto-char start)
              (evil-next-line)
              (while (> (current-indentation) 0)
                (python-nav-forward-statement))
              (beginning-of-line)
              (point-marker))))))

(after! python
  (map! :map python-mode-map
        :localleader
        (:prefix ("e" . "Eval")
                 "b" #'python-shell-send-buffer
                 "r" #'python-shell-send-region
                 "d" #'kev/python-shell-send-toplevel)))
#+end_src

#+RESULTS:

** Clojure

nice keybindings

#+begin_src elisp
(setq kevin-clojure-playbook
  '(("portal" . "(do (require 'portal.api) (portal.api/open) (add-tap #'portal.api/submit))")
    ("sync deps" . "((requiring-resolve 'clojure.repl.deps/sync-deps) :aliases [:test :dev :local-dev])")
    ("prn space" . "(doseq [_ (range 40)] (prn \"\"))")
    ("humane test output" . "((requiring-resolve 'pjstadig.humane-test-output/activate!))")
    ("warn on reflection" . "(set! *warn-on-reflection* true)")))

(defun kevin-clojure-playbook (&optional output-to-current-buffer)
  "evaluate something from the playbook (w/ cider)"
  (interactive "P")
  (let ((cmd (ivy-read "clj cmd: "
                       kevin-clojure-playbook
                       :history 'kevin-clojure-playbook)))
    (cider-interactive-eval (cdr (assoc cmd kevin-clojure-playbook))
                            nil
                            (cider-defun-at-point 'bounds)
                            (cider--nrepl-pr-request-map))))

(defun kev-format-form (beg end)
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (save-excursion
                   (let ((end (progn (end-of-defun)
                                     (point))))
                     (clojure-backward-logical-sexp)
                     (list (point) end)))))
  (save-excursion
    (clojure-align beg end)
    (lsp-format-region beg end)))

(add-hook! clojure-mode
  ;;(aggressive-indent-mode) this shit so slow :(
  (hs-minor-mode 1)

  (setq cider-comment-prefix "(comment\n"
        cider-comment-continued-prefix "  "
        indent-region-function nil
        cider-comment-postfix ")"

        clojure-toplevel-inside-comment-form t
        ;; code alignment
        clojure-align-forms-automatically t

        ;; because lsp indent is incredibly annoying for clojure
        indent-region-function nil
        )


  (defun kev-format-buffer ()
    (interactive)
    (save-excursion
        (lsp-format-buffer)
        (clojure-align (point-min) (point-max))))

  (define-clojure-indent
    (into 1)
    (do-template 2)
    (sc.api/letsc 1)
    (macrolet '(1 ((:defn)) nil)))
  )

(define-advice aggressive-indent--indent-if-changed (:around (orig-fun buffer) aggressive-indent-advice)
  (when (not (with-current-buffer buffer
               (evil-insert-state-p)))
    (funcall orig-fun buffer)))

;; prettier indentation!
(define-advice cider-maybe-insert-multiline-comment
    (:around (orig-fun result comment-prefix continued-prefix comment-postfix) cider-comment-advice)
  (funcall orig-fun result comment-prefix continued-prefix comment-postfix)
  (save-excursion
    (let ((end (point)))
      (sp-backward-sexp)
      (kev-indent (point) end))))

(map! :mode clojure-mode
      :localleader
      "e." (lambda (&optional output-to-current-buffer)
             (interactive "P")
             (save-excursion
               (goto-char (- (cadr (cider-list-at-point 'bounds)) 1))
               (cider-eval-last-sexp output-to-current-buffer)))
      "ef" #'cider-eval-defun-at-point
      "ep" #'kevin-clojure-playbook
      "e;" (lambda (&rest output-to-current-buffer)
             (interactive "P")
             (save-excursion
               (goto-char (- (cadr (cider-list-at-point 'bounds)) 0))
               (cider-pprint-form-to-comment 'cider-last-sexp nil)))
      "et" (lambda (&optional output-to-current-buffer)
             "run toplevel as clojure test; return report"
             (interactive "P")
             (cider-interactive-eval (concat "(binding [clojure.test/*report-counters* (ref clojure.test/*initial-report-counters*)]"
                                             "(clojure.test/test-vars [\n"
                                             (cider-defun-at-point)
                                             "])"
                                             "(prn @clojure.test/*report-counters*)"
                                             "@clojure.test/*report-counters*)")
                                     nil
                                     (cider-defun-at-point 'bounds)
                                     (cider--nrepl-pr-request-map)))
      "en" #'cider-eval-ns-form
      "="  #'kev-format-form
      "ip" #'(lambda () (interactive) (insert "clojure.pprint/pprint")))

(defun cider-jack-in-babashka ()
  "Start an babashka nREPL server for the current project and connect to it."
  (interactive)
  (let* ((default-directory (project-root (project-current t)))
         (process-filter (lambda (proc string)
                           "Run cider-connect once babashka nrepl server is ready."
                           (when (string-match "Started nREPL server at .+:\\([0-9]+\\)" string)
                             (cider-connect-clj (list :host "localhost"
                                                      :port (match-string 1 string)
                                                      :project-dir default-directory)))
                           ;; Default behavior: write to process buffer
                           (internal-default-process-filter proc string))))
    (set-process-filter
     (start-file-process "babashka" "*babashka*" "bb" "--nrepl-server" "0")
     process-filter)))
#+end_src

#+RESULTS:
: cider-jack-in-babashka

lsp utils

#+begin_src elisp
;; develop on clojure-lsp
;; "~/Documents/me/misc/clojure-lsp/clojure-lsp"
;; else just "clojure-lsp"
(setq lsp-clojure-custom-server-command nil)

(defun lsp-clojure-nrepl-connect ()
  "Connect to the running nrepl debug server of clojure-lsp."
  (interactive)
  (let ((info (lsp-clojure-server-info-raw)))
    (save-match-data
      (when-let (port (and (string-match "\"port\":\\([0-9]+\\)" info)
                           (match-string 1 info)))
        (cider-connect-clj `(:host "localhost"
                             :port ,port))))))
#+end_src

cider configs

#+begin_src elisp
;;(setq cider-comment-prefix "\n;; => ")
(setq kev-clojure-cli-param-hist '("-M:test:dev:local-dev"
                                   "-M:cljs"
                                   "-X:local-dev:cljs"
                                   "-M:local-dev:server:cljs # clj(s) projects "
                                   "-A:test:dev:local-dev -m nrepl.cmdline --middleware '[cider.nrepl/cider-middleware]' --interactive --color # no reveal for java8"
                                   ))


(put 'cider-custom-cljs-repl-init-form 'safe-local-variable 'identity)
(use-package! cider
  ;; for some reason, this works. But after! doesn't work.
  ;; neither does `:hook (clojure-mode . cider-mode)`. Both cause the doom module
  ;; config to be ignored. This doesn't though
  :after-call clojure-mode-hook
  :config
  (setq cider-comment-prefix "\n;; => "
        cider-repl-buffer-size-limit 100)


        ;; fix shadow to not auto-evaluate forms!
        ;; well, can adjust this. for now, keeping
        ;; BUT maybe it would be a good idea to actually
        ;; look at shadow.cljs.devtools.api/nrepl-select
        ;; (setcar
        ;;  (cdr (seq-find (lambda (e)
        ;;                 (eq 'shadow (car e)))
        ;;                 cider-cljs-repl-types))
;;         'cider-shadow-select-cljs-init-form)


  ;; this is to fix the cider jack in to by my own thing because they changed some
  ;; version and got rid of =cider-clojure-cli-parameters=
  (setq cider-jack-in-dependencies nil)
  (setq cider-jack-in-auto-inject-clojure nil)
  (setq cider-inject-dependencies-at-jack-in t)
)

  ;; NOTE: instead set cider-jack-in-cmd with .dir-locals.el !!!
  ;; see how ppl do it:
  ;; https://github.com/djblue/portal/blob/48bda9b9b59795802a18f301d982b1f41d0db3c6/.dir-locals.el#L1
  ;;

  ;; (define-advice cider-jack-in-params (:around (orig-fun project-type) jack-in-param-advice)
  ;;   (pcase project-type
  ;;     ('clojure-cli (ivy-read "clojure cli params: "
  ;;                             kev-clojure-cli-param-hist
  ;;                             :history 'kev-clojure-cli-param-hist))
  ;;     (_ (funcall orig-fun project-type))))
;; (define-advice cider-inject-jack-in-dependencies (:around (orig-fun global-opts params project-type &optional command)
;;                                                           inject-deps-advice)
;;   (pcase project-type
;;     ('clojure-cli params)
;;     (_ (funcall orig-fun global-opts params project-type command))))

;; cider window popup!
;;
;; use display-buffer-alist to fix what we do!
;; cider-repl-pop-to-buffer-on-connect is 'display-only
;; cider-repl-display-in-current-window
;; (cider-jack-in)
(setf (alist-get "\\*cider-repl.*" display-buffer-alist)
      '(display-buffer-use-least-recent-window))

(define-advice nrepl-start-server-process (:around (orig-fun directory cmd on-port-callback) nrepl-start-server-process-advice)
  ;; insert prefix because sdkman doesn't insert the environment in emacs automatically
  ;; idk how to set it for the current emacs shell. may not be possible
  ;; was: "source \"$HOME/.sdkman/bin/sdkman-init.sh\" && { echo \"no\n\" | sdk env || echo 'no .sdkman?' } && sdk c java && "
  (let ((cmd-prefix "source \"$HOME/.sdkman/bin/sdkman-init.sh\" && echo \"no\\n\" | sdk c java && "))
    (funcall orig-fun directory (concat cmd-prefix cmd) on-port-callback)))
#+end_src

#+RESULTS:
: nrepl-start-server-process@nrepl-start-server-process-advice

** lsp
for code alignment, look at [[https://github.com/clojure-emacs/clojure-mode#indentation-of-macro-forms][clojure mode docs]] and at [[https://docs.cider.mx/cider/indent_spec.html][cider docs]]

#+begin_src elisp
(add-hook! 'lsp-mode-hook

           (lsp-ui-mode 1)
           ;; I don't think these are required?
           ;; (evil-set-command-property 'evil-ex-search-next :jump nil)
           ;; (evil-set-command-property 'evil-ex-search-backward :jump nil)
           (map! :map lsp-command-map
                 ;; TODO maybe prefix will fix lack of docs
                 "gb" #'xref-go-back
                 "gf" #'xref-go-forward
                 "d" #'lsp-ui-doc-glance)
           (map! "s-l" lsp-command-map)

           (lsp-diagnostics-mode 0)

           ;; TODO
           ;; look at lsp--default-directory-for-connection
           ;; how to lsp thing is set up and where it gets the config
           (setq lsp-ui-doc-position 'at-point
                 lsp-enable-symbol-highlighting 't
                 ;; perf stuff
                 lsp-file-watch-threshold 10000
                 gc-cons-threshold (* 100 1024 1024)
                 read-prcess-output-max (* 1024 1024)
                 lsp-ui-doc-enable nil
                 lsp-ui-doc-position 'at-point
                 lsp-headerline-breadcrumb-enable nil
                 lsp-ui-sideline-enable nil
                 lsp-ui-sideline-show-code-actions nil
                 lsp-modeline-diagnostics-enable nil

                 ;; focus help window when it shows up
                 help-window-select t

                 ;; change to locally do clojure lsp
                 lsp-clojure-custom-server-command '("zsh" "-c" "clojure-lsp")

                 ;;;; Xref / definition stuff
                 lsp-references-exclude-definition 't
                 ;; will treat everything as definition
                 lsp-xref-force-references 't
                 ;; Don't do this. it ignores multiples
                 xref-auto-jump-to-first-definition nil
                 xref-show-definitions-function 'xref-show-definitions-buffer-at-bottom

                 ;; ikd this was here before
                 cider-eldoc-display-for-symbol-at-point nil ;; disable cider eldoc
                 cider-repl-display-help-banner nil  ;;       disable help banner
                 )
           ;; don't know why I had these actually
           ;; necessary for showing references without relative path
           ;;
           ;; (setq ivy-xref-use-file-path t)
           ;; (setq xref-file-name-display 'project-relative)
           ;; (after! xref
           ;;   (setq xref-show-definitions-function #'xref-show-definitions-buffer-at-bottom))

           )

;; really disable cider eldoc
;; idk if this is actually needed anymore
;; (define-advice cider-eldoc-setup (:around (orig      -fun) cider-eldoc-advice)
;;   nil)

;; (add-hook! lsp-mode
;;   (turn-on-better-jumper-mode))

;; only done once, not every buffer
(after! lsp-mode
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]public\\'" "")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\tmp\\'")
  )


;; makes so aggressive indent won't go until you exit insert mode
(define-advice aggressive-indent--indent-if-changed (:around (orig-fun buffer) aggressive-indent-advice)
  (when (not (with-current-buffer buffer
               (evil-insert-state-p)))
    (funcall orig-fun buffer)))
#+end_src


#+RESULTS:
: aggressive-indent--indent-if-changed@aggressive-indent-advice

** go
#+begin_src elisp

(add-hook! go-mode-hook)
#+end_src
** cue

#+begin_src emacs-lisp
(defconst cue-keywords
  '("package" "import" "for" "in" "if" "let"))

(defconst cue-constants '("null" "true" "false"))

(defconst cue-types
  '("int" "float" "string" "bool" "bytes"))

(defvar cue--font-lock-keywords
  `(("//.*" . font-lock-comment-face)
    (,(regexp-opt cue-constants 'symbols) . font-lock-constant-face)
    (,(regexp-opt cue-keywords 'symbols) . font-lock-keyword-face)
    (,(regexp-opt cue-types 'symbols) . font-lock-type-face)))

;;;###autoload
(define-derived-mode cue-mode prog-mode "CUE"
  "Major mode for the CUE language."

  ;; Comments
  (setq-local comment-start "// ")
  (setq-local comment-end "")
  (setq-local comment-start-skip "//[[:space:]]*")

  (setq indent-tabs-mode t)

  (setq-local font-lock-defaults '(cue--font-lock-keywords)))

;;;###autoload
(add-to-list 'auto-mode-alist '("\\.cue\\'" . cue-mode))
#+end_src

* TODO
- [ ] projectile terminal (gets or creates terminal at root of current project)
- [ ] default popup windows
- [ ] lsp-mode & cider-mode competition?
  - company backend (lsp seems completely disabled for this?)
  - eldoc stuffs they definitely compete
- [ ] company mode backend for text completion?
- [ ] move machine-specific setup into separate file so they don't have to keep changing
- [ ] clojure errors go to popwin
- [ ] keybindings
  - terminal
  - eval-previously-evaled-test
- [ ] auto right align for maps and lets (like how aggressive indent works)
- [ ] popup for cider errors instead of other window
- [ ] archive todo
  - would also like a popup to ask where to put it?
  - this could have much overlapping functionality with add-to-list
    which allows you insert an org-roam link and add that link to a
    list somewhere and then you put whatever at that link
- [ ] clojure errors go to popwin, no focus?
- [X] advice for dired, select file, do delete all dired buffers so back buffer works
- [X] eval-test-around-point
- [X] modify autoindent to be smarter! maybe use clj-kondo?
- [X] paredit
- [X] fix eval to comment
- [X] doom modeline
- [X] eval sexp around point
