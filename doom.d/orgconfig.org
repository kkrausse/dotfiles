:PROPERTIES:
:header-args: :results silent
:END:
#+TITLE: Doom Emacs Config

this setup was taken from [[https://www.youtube.com/watch?v=SzA2YODtgK4&ab_channel=thoughtbot][this video]] and the [[https://github.com/hrs/dotfiles/blob/main/emacs/dot-emacs.d/configuration.org][setup he uses]].

notes:
- direction is to prefer `map!`, `after!`, and `add-hook!` as opposed to extensive
   `use-package` commands

* initial setup / utils

#+begin_src elisp
;; -*- lexical-binding: t; -*-
(load "~/.doom.d/machine-specific.el")

(defmacro kev/comment (&rest args)
  nil)

;; I'm *pretty sure* this helps goto find the doom specific functions
(setq find-library-source-path
      (append load-path
              (list
               (expand-file-name "lisp" "~/.config/emacs")
               (expand-file-name "lisp/lib" "~/.config/emacs"))))

;; finer grained font size control
(setq doom-font-increment 1
      use-package-always-defer 't
      use-package-compute-statistics 't)

;; c source directory
;; `git clone --branch emacs-28.2 --depth 1 https://github.com/emacs-mirror/emacs repos/emacs`
(setq find-function-C-source-directory "~/.doom.d/repos/emacs/src")



(add-hook 'shell-mode-hook (lambda ()
                             (company-mode -1)))

;; DONT add regex search to the jump stack!
(evil-set-command-property 'evil-ex-search-next :jump nil)
(evil-set-command-property 'evil-ex-search-backward :jump nil)

;; company mode setup

(after! company
  ;; TODO why do I need this?
  ;; something wrong with the config I think
  (global-company-mode -1)

  ;; (add-hook! 'org-mode-hook
  ;;   (setq company-idle-delay 0.5))

  (setq company-idle-delay 0.5)
  (company-mode-on)
  (setq company-minimum-prefix-length 1
        company-dabbrev-minimum-length 2
        company-dabbrev-ignore-case 'keep-prefix
        company-dabbrev-other-buffers t)
  ;; I don't want tab to cycle
  (map! :map company-active-map
        "<tab>" #'company-complete)
  )

;; don't like cider doing all this shit fucking my other windows.
;; just use display buffer alist to use same window
(setq pop-up-windows nil)
;; diplay buffer stuff
(setq display-buffer-base-action '((display-buffer-reuse-window
                                    display-buffer-same-window
                                    display-buffer-use-least-recent-window) . nil))
;; example to set alternames based on buffer name,
;; (setf (alist-get "\\*cider-repl.*" display-buffer-alist)
;;       '(display-buffer-use-least-recent-window))


;; multi term stuff , which I don't use anymore really
(setq multi-term-program "/bin/zsh")
(setq-default explicit-shell-file-name "/bin/zsh")
(setq multi-term-switch-after-close nil)


;; I think needed for env vars in the shell?
;; might actuall not be
(use-package! exec-path-from-shell :defer t)
(after! exec-path-from-shell
  (dolist (var '("JAVA_HOME"))
    (add-to-list 'exec-path-from-shell-variables var))
  (exec-path-from-shell-initialize))
#+end_src

* UI preferences
** Theme
#+begin_src elisp
;; theme shite

;; see https://www.ditig.com/256-colors-cheat-sheet for colors! should just do 256 tbh so
;; also, maybe can look at default doom themes for some guidance

;; my custom shit
;; (setq doom-customize-theme-hook nil)
(load-theme 'my-vibrant t)
(setq doom-theme 'my-vibrant)

;;(setq doom-theme 'doom-vibrant)
;; TODO:
;; doom-vibrant, but port over my changes to just the hook
;; doom-one is default and ssems like it would have most support for doom-specific things but it's is super low contrast so I think I need to like overlay the solarized colors on the featuresset of doom-one
;; note: that it is the default also means it would be overly configurable and gross to work with
;; also note: I started with vibrant but changed literally everything. It's not the same theme anymore at all.

;; doom-solarized-dark
;; doom-solarized-dark-high-contrast
;; doom-molokai

;; is good, but it's annoying because you don't rely completely on your theme
;; but this must be set first since things rely on this I guess
;; (custom-set-faces! `(default :background ,(doom-color 'bg)))
#+end_src

** Modeline

doom-modeline package for [[https://github.com/seagle0128/doom-modeline][dopeness]]

#+begin_src elisp :results silent
(after! doom-modeline
  (doom-modeline-mode 1)
  (setq doom-modeline-percent-position nil
        doom-modeline-height 1)

  (column-number-mode 1)
  ;; compare to https://github.com/seagle0128/doom-modeline/blob/e521d32c2d670dc664424857e3fc18a37f0728f6/doom-modeline.el#L90
  ;; also, look through

;; original
;; (doom-modeline-def-modeline 'main
;; '(eldoc bar workspace-name window-number modals matches follow buffer-info remote-host buffer-position word-count parrot selection-info)
;; '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus github debug repl lsp minor-modes input-method indent-info buffer-encoding major-mode process vcs checker time))

  ;; look
  ;; got rid of lsp, modals, repl, buffer-encoding, major-mode, checker
  (doom-modeline-def-modeline 'kev-main-modeline
      '(eldoc bar workspace-name window-number matches follow buffer-info remote-host buffer-position word-count parrot selection-info)
      '(compilation objed-state misc-info persp-name battery grip irc mu4e gnus github debug lsp minor-modes input-method indent-info process vcs))

  (add-hook! 'doom-modeline-mode-hook
    (doom-modeline-set-modeline 'kev-main-modeline 'default))
  )
#+end_src


and make multi-term use it

#+begin_src elisp
(add-hook! term-mode-hook
           'doom-modeline-mode)
#+end_src
* My Plugins
** ellama
#+begin_src elisp
;; NOTE will eval NOW if package already loaded
(after! ellama
  (setq
   ellama-provider (make-llm-ollama
                    :scheme "http"
                    :host "localhost"
                    :port 11434
                    :chat-model "zephyr"
                    :embedding-model "zephyr")))
#+end_src

** gpt
#+begin_src elisp


(defun surrounding-fn-bounds ()
  (cond
   ((eq major-mode 'clojure-mode) (cider-defun-at-point 'bounds))
   ((eq major-mode 'emacs-lisp-mode) (let (beg end)
                                       (save-excursion
                                         (end-of-defun)
                                         (beginning-of-defun)
                                         (setq beg (point))
                                         (end-of-defun)
                                         (setq end (point)))
                                       (list beg end)))
   ('t nil)))


(defun other-window ()
  "gets the window that is not the current one"
  (car (seq-filter (lambda (w) (not (eq (get-buffer-window) w)))
                   (window-list))))

;; TODO make this read from env var.
(defvar openai-api-key-1 "***")

(defun double-escape-string (s)
  (thread-last s
               (s-replace "\"" "\\\"")
               (s-replace "\n" "\\n")))

(defun atom-replace (old new tree)
  (if (atom tree)
      (if (eq old tree)
          new
        tree)
    (cons (atom-replace old new (car tree)) (atom-replace old new (cdr tree)))))

(defmacro thread$ (head &rest forms)
  (if (car forms)
      `(athread ,(atom-replace '$ head (car forms)) ,@(cdr forms))
    head))

(defun read-resp-buffer (b)
  (with-current-buffer b
    (goto-char (point-min))
    (re-search-forward "^$")
    (thread$ (json-read)
             (alist-get 'choices $)
             (aref $ 0)
             (alist-get 'text $))))

(defvar test-resp)

(cl-defun make-openai-request (&key url data handle)
  "makes an http request to the openai edit api to the davinci code model and passes
in `input' to get back edits made by the model"
  (let* ((url-request-method "POST")
         (url-request-data data)
         (url-request-extra-headers
          `(("Content-Type" . "application/json")
            ("Authorization" . ,(concat "Bearer " openai-api-key-1))))
         (_ (message (format "calling: %s with data: %s" url data)))
         (resp (url-retrieve-synchronously url)))
    (setq test-resp resp)
    (funcall handle resp)))


;; (progn test-resp)
;; (with-current-buffer test-resp
;;   (buffer-string))

;; (read-resp-buffer test-resp)

(defun code-davinci-edit-data (input)
  `(:url "https://api.openai.com/v1/edits"
    ;     "http://localhost:8000"
    :data
    ,(json-encode
      `((model . "code-davinci-edit-001")
        (input . ,input)
        (instruction .
         "Add code to the body of the function so it completes the documented task as simply as possible")
        (temperature . 0)
        (top_p . 1)))
    :handle ,(lambda (resp) (read-resp-buffer resp))))

(defun code-davinci-insert-data (input &optional separator)
  (unless separator
    (setq separator "\\[insert\\]"))
  (cl-destructuring-bind (pre post) (s-split separator input)
    (unless (and pre post)
      (throw 'input-error (format "need separater '%s'" separator)))
    `(:url "https://api.openai.com/v1/completions"
      :data
      ,(json-encode
        `((model . "code-davinci-002")
          (prompt . ,pre)
          (suffix . ,post)
          (temperature . 0)
          (max_tokens . 512)
          (top_p . 1)
          (frequency_penalty . 0.3)
          (presence_penalty . 0)))
      :handle (lambda (resp)
                (let ((insert (read-resp-buffer resp)))
                  (concat ,pre insert ,post))))))

(defun test-region (start end)
  (interactive "r")
  (print
   (list start end (buffer-substring-no-properties start end))))

(defun gpt-edit-2 ()
  (interactive)
  (let ((bounds (if (region-active-p)
                    (list (region-beginning) (region-end))
                  (surrounding-fn-bounds))))
    (unless bounds
      (message "unable to get fn bounds. Language not supported?"))
    (when bounds
      (replace-region-contents
       (car bounds)
       (cadr bounds)
       (lambda ()
         (thread$ bounds
                  (apply 'buffer-substring-no-properties $)
                  (code-davinci-insert-data $)
                  (apply 'make-openai-request $)))))))

#+end_src
** paredit

#+begin_src elisp
(define-minor-mode kevin-paredit-mode
  "lisp state for paredit"
  :lighter " kevin paredit"
  (setq evil-move-beyond-eol kevin-paredit-mode))

(defmacro kevin/sp-kill-movement-fn (name &rest body)
  `(defalias (intern (concat "kevin/kill-to-"
                             (symbol-name (quote ,name))))
     (lambda ()
       (interactive)
       (let ((p (point)))
         ,@body
         (sp-kill-region p (point))))))

(evil-define-minor-mode-key
  '(normal visual) 'kevin-paredit-mode
  "B" 'sp-backward-barf-sexp
  "b" 'sp-forward-barf-sexp
  "s" 'sp-forward-slurp-sexp
  "S" 'sp-backward-slurp-sexp
  "t" 'sp-transpose-sexp
  "f" (lambda ()
        (interactive)
        (print (list "use region" (use-region-p)))
        (if (use-region-p)
            (let ((m (mark))
                  (s (region-beginning)))
              (clojure-align (region-beginning) (region-end))
              (lsp-format-region (region-beginning) (region-end))
              ;; (print (list "region:" (region-beginning) (region-end)
              ;;              (region-active-p)))
              )
          (progn
            (sp-mark-sexp)
            (clojure-align (region-beginning) (region-end))
            (lsp-format-region (region-beginning) (region-end))
            (pop-mark))))
  ;; parens
  "\"" (lambda ()
         (interactive)
         (sp-wrap-with-pair "\""))
  "[" 'sp-wrap-square
  "{" 'sp-wrap-curly
  "w" 'sp-wrap-round
  "W" 'sp-unwrap-sexp
  "m" 'sp-mark-sexp

  ;; killing
  "da" 'sp-splice-sexp-killing-around
  "d$" (kevin/sp-kill-movement-fn
        end-of-sexp
        (sp-end-of-sexp))
  "d0" (kevin/sp-kill-movement-fn
        beginning-of-sexp
        (sp-beginning-of-sexp))
  "dl" (kevin/sp-kill-movement-fn
        next-sexp
        (sp-forward-sexp))
  "dh" (kevin/sp-kill-movement-fn
        beginning-of-sexp
        (sp-backward-sexp))

  ;; movement
  "h" 'sp-backward-sexp
  "H" 'sp-backward-down-sexp
  "l" 'sp-forward-sexp
  "L" 'sp-down-sexp
  "j" 'sp-down-sexp
  "k" 'sp-backward-up-sexp
  "." 'kevin-paredit-mode
  (kbd "<escape>") 'kevin-paredit-mode)

(general-define-key
 :states '(normal visual)
 :keymaps 'global
 :prefix "SPC"
 "k" 'kevin-paredit-mode)
#+end_src

* General Setup
** remote shells
#+begin_src elisp

;; see https://www.gnu.org/software/tramp/#Relevant-connection-properties-to-override
;; and (tramp-methods)
(after! tramp
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/ssh:kkrausse@diesel2:")
                     "remote-shell" "/usr/bin/zsh")))
#+end_src
** utility functions
#+begin_src elisp
(defmacro kev-setq-local (&rest kvs)
  `(progn
     ,@(mapcar
        (lambda (pair)
          (cl-destructuring-bind (sym val) pair
            `(progn
               (make-local-variable ',sym)
               (setq ,sym ,val))))
        (seq-partition kvs 2))))

(defmacro kev-fn (arglist &rest body)
  (let ((fargsym (gensym "arg")))
    `(lambda (,fargsym)
       (cl-destructuring-bind ,arglist
           ,fargsym
         ,@body))))

;; just realized this isn't even needed because the builtin
;; browse at remote already handles this exact situation
(defun kev-get-commit (beg end)
  (interactive "r")
  (require 'browse-at-remote)
  (let* ((commit (string-trim (buffer-substring beg end))) ;; was using (current-kill 0), but annoying
         (url
          (browse-at-remote--commit-url commit)))
    (kill-new url)
    (message (concat "copied: " url))))

(defun kev-project-ignored-p (root)
  (or (doom-project-ignored-p root)
      (string-match-p "/node_modules/" root)
      (string-match-p "/.cache/" root)
      (string-match-p "/.gitlibs/" root)))

(setq projectile-ignored-project-function 'kev-project-ignored-p)

;; evil-beginning-of-line
;; newline-and-indent
;; evil-next-line
;; FIXME the problem is that the value of end-point is no longer valid because (indent-according-to-mode) changes the buffer!
(defun kev-indent (beg end)
  "indents highlighted."
  (interactive "r")
  (save-excursion
    (let ((end-line (line-number-at-pos (- end 1))))
      (goto-char beg)
      (indent-according-to-mode)
      ;; such as a way to do the last line, but never try to go past it
      (while (< (line-number-at-pos)
                end-line)
        (evil-next-line)
        (indent-according-to-mode)))))

(defun projectile-term ()
  "if terminal exists in project, switch to it. else, create at project root"
  (interactive)
  (let ((term-buf (seq-some (lambda (b)
                              (with-current-buffer b
                                (and (derived-mode-p 'vterm-mode) b)))
                            (projectile-project-buffers))))
    (if term-buf
        (switch-to-buffer term-buf)
      (progn
        ;; no need to open in root bc vterm here does that!
        ;;(find-file (projectile-project-root))
        (+vterm/here nil)))))

(defun get-displayed-buffer (pred)
  (seq-some (lambda (w) (with-current-buffer (window-buffer w)
                        (and (funcall pred)
                             (window-buffer w))))
          (window-list)))

(defun call-previous-term-cmd ()
  (interactive)
  (with-current-buffer (get-displayed-buffer (lambda () (eq 'term-mode major-mode)))
    (term-send-up)
    (term-send-return)))

(defun kev/copy-relative-file-and-lines ()
  "Copy relative file name with Git-style line numbers (e.g., path/to/file.ext#L5-L12) to the clipboard.
If a region is active, include line numbers. If the region has highlights, show a message."
  (interactive)
  (let* ((file (or buffer-file-name (dired-get-file-for-visit)))
         (project-root (or (when (fboundp 'project-root)
                             (let ((proj (project-current)))
                               (when proj (project-root proj))))
                           default-directory))
         (relative-path (file-relative-name file project-root))
         (start (if (use-region-p) (region-beginning) (point)))
         (end   (if (use-region-p) (region-end) (point)))
         (start-line (line-number-at-pos start))
         (end-line   (line-number-at-pos (if (eq end (point-min)) end (1- end))))
         (line-suffix (if (use-region-p)
                          (if (= start-line end-line)
                              (format "#L%d" start-line)
                            (format "#L%d-L%d" start-line end-line))
                        ""))
         (final (concat relative-path line-suffix))
         (highlight-overlays (cl-remove-if-not
                              (lambda (ov) (overlay-get ov 'face))
                              (overlays-in start end))))
    (kill-new final)
    (message "%s%s"
             (if highlight-overlays "[Highlighted] " "")
             final)))


(require 'cl-lib)

(defun my-common-prefix (str1 str2)
  "Return the longest common prefix of STR1 and STR2."
  (let ((len (min (length str1) (length str2)))
        (i 0))
    (while (and (< i len)
                (eq (aref str1 i) (aref str2 i)))
      (setq i (1+ i)))
    (substring str1 0 i)))

(defun my-switch-to-nearest-vterm ()
  "Switch to the vterm buffer with the longest matching directory path.
If no vterm buffer matches the current directory, print a message and return nil."
  (interactive)
  (let* ((current-dir (expand-file-name default-directory))
         (vterm-buffers (cl-remove-if-not
                         (lambda (buf) (eq (buffer-local-value 'major-mode buf) 'vterm-mode))
                         (buffer-list)))
         (best-match nil)
         (longest-match-length 0))
    (dolist (buf vterm-buffers)
      (let* ((buf-dir (expand-file-name (buffer-local-value 'default-directory buf)))
             (common-prefix (my-common-prefix current-dir buf-dir))
             (match-length (length common-prefix)))
        (when (and common-prefix (> match-length longest-match-length))
          (setq best-match buf)
          (setq longest-match-length match-length))))
    (if best-match
        (progn
          (switch-to-buffer best-match)
          best-match)
      (message "No vterm buffer found with a matching directory. try 'spc o t',")
      nil)))

;; just map everywhere
(map!
 (:prefix ("SPC j" . "kevin stuff")
          :nv  "i" 'kev-indent
          :nv "t" 'my-switch-to-nearest-vterm
          :nv "pp" 'jet-to-clipboard
          :nv "pt" 'call-previous-term-cmd
          (:prefix ("y" . "yank")
           :nv "r" #'kev/copy-relative-file-and-lines)
          (:prefix ("e" . "edit")
                   :n "e" 'edit-env-file
                   :n "c" 'doom-edit-config
                   :n "t" '(lambda () (interactive) (find-file "~/dotfiles/tmp.org")))))


;; (-> 'display-buffer-alist
;;         (add-to-list '(".*magit.*"
;;                        (display-buffer-reuse-window display-buffer-same-window))))

(add-hook! magit-mode
  (map!
   (:prefix ("SPC j" . "kevin stuff")
            :map magit-section-mode-map
            :nv "c" 'kev-get-commit)))


;; this is actually great http://clhs.lisp.se/Body/03_dd.htm
;; aslo the cl-defmacro definition has some of that info

;; requires a (require 'straight) call. so quote it for now

(defun kev-list-packages ()
  (interactive)
  (mapcar (kev-fn (build-time deps (&whole whole &key type package &allow-other-keys))
                  (print (list :pack package
                               :buildt build-time
                               :type type)))
          (hash-table-values straight--build-cache)))

;; stolen from borkdude: https://github.https://github.com/borkdude/prelude/blob/master/personal/init.el#L195om/borkdude/prelude/blob/master/personal/init.el#L195
(defun copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))
#+end_src

** Keybindings
#+begin_src elisp
;; sets comma as spc m
(setq evil-snipe-override-evil-repeat-keys nil)
(setq doom-localleader-key ",")

;; vinegar
(define-key evil-normal-state-map (kbd "-") 'dired-jump)

;; for evil-escape package
;; so much better than key chord!!
(setq-default evil-escape-key-sequence "jj")
(setq-default evil-escape-delay 0.2)

#+end_src

** Random Config
#+begin_src elisp
;; I think this just defaults
(setq orderless-matching-styles '(orderless-literal
                                  orderless-regexp))
(setq completion-styles '(orderless basic))
(setq projectile-switch-project-action #'projectile-dired)

;; makes the above thing actially work
(setq counsel-projectile-switch-project-action (lambda (project)
                                                 (dired (projectile-project-root project))))

;; delete dired buffers when switching
(define-advice dired-find-file (:around (orig-fun &rest _) dired-find-file-advice)
  (let ((prev-buf (current-buffer)))
    (funcall-interactively orig-fun)
    (when (and (eq 'dired-mode (buffer-local-value 'major-mode prev-buf))
               ;; ONLY FOR dired buffer! Leave it if we go to a file?
               (eq 'dired-mode (buffer-local-value 'major-mode (current-buffer)))
               ;; make sure it's not currently displayed
               (not (seq-find (lambda (w)
                                (eq prev-buf
                                    (window-buffer w)))
                              (window-list)))
               (not (eq prev-buf (current-buffer))))
      (kill-buffer prev-buf))))

(define-advice dired-up-directory (:around (orig-fun &rest args) dired-up-advice)
  (let ((prev-buf (current-buffer)))
    (apply #'funcall-interactively orig-fun args)
    (when (and (eq 'dired-mode (buffer-local-value 'major-mode prev-buf))
               ;; make sure it's not currently displayed
               (not (seq-find (lambda (w)
                                (eq prev-buf
                                    (window-buffer w)))
                              (window-list)))
               (not (eq prev-buf (current-buffer))))
      (kill-buffer prev-buf))))




;; github yank line link
;; (setq browse-at-remote-remote-type-domains
;;       (cons '("github.dev.pages" . "github") browse-at-remote-remote-type-domains))
;; dont prompt on exit
(setq confirm-kill-emacs nil)
;; when exit insert mode exit
(setq evil-move-cursor-back t)

;; flycheck has horrible perf.. maybe?
(setq flycheck-check-syntax-automatically '(save idle-change))
(setq flycheck-disabled-checkers '(emacs-lisp-checkdoc))

#+end_src

line numbers

#+begin_src elisp
;; so we *can* display line numbers, but need to disable it for various
;; modes we don't want by default
(setq display-line-numbers-type t)
(remove-hook! '(prog-mode-hook text-mode-hook conf-mode-hook)
  #'display-line-numbers-mode)
#+end_src
** perf fixes
#+begin_src elisp
(defmacro timed-cached-funcall (time fn)
  (let ((last-time (gensym "last-time"))
        (cached-val (gensym "cached-val"))
        (fn-args (gensym "fn-args")))
    `(let ((,last-time -100.0)
           (,cached-val nil))
       (lambda (&rest ,fn-args)
         (when (> (- (float-time) ,last-time) ,time)
           (setq ,last-time (float-time))
           (setq ,cached-val (apply (quote ,fn) ,fn-args)))
         ,cached-val))))

;; this IS necessary. fuckin shit is slow without it
;; (setq kevin-project-root "johnson")
;; (setq kevin-project-root-timer
;;       (run-with-idle-timer 1 t (lambda () (setq kevin-project-root (projectile-project-root)))))
(setq kev-cached-project-root (timed-cached-funcall 1.0 projectile-project-name))

(setq frame-title-format '((:eval
                            (funcall kev-cached-project-root))))

;; noticed bad perf here
(setq kev-cached-modeline-buffer-file-state
      (timed-cached-funcall 1.0 doom-modeline-update-buffer-file-state-icon))

(define-advice doom-modeline-update-buffer-file-state-icon
    (:around (orig-fun &rest _) doom-modeline-advice)
  (funcall kev-cached-modeline-buffer-file-state))
#+end_src

** Project management
*** git
#+begin_src elisp
(use-package! browse-at-remote
  :config
  (print (list "regexps: " browse-at-remote-remote-type-regexps))
  (add-to-list 'browse-at-remote-remote-type-regexps
               '(:host "github.dev.pages$" :type "github"))
  )
#+end_src

* Lang
** sql
#+begin_src elisp

(defvar kev/duckp "duckp")

;; starts buffer with it
(defun kev/start-duck ()
  (interactive)
  (make-comint kev/duckp "duckdb"))

(defun kev/shell-send-paragraph ()
  (interactive)
  (let ((start (point)))
    (save-excursion
      (process-send-region
       kev/duckp
       (progn (backward-paragraph)
              (forward-char)
              (beginning-of-line)
              (point))
       (progn (goto-char start)
              (forward-paragraph)
              (min (buffer-end 1)
                   (point)))))))

(defun kev/shell-send- (start end)
  (interactive (list (region-beginning) (region-end)))
  (if (region-active-p)
      (process-send-region kev/duckp start end)
    (kev/shell-send-paragraph)))

(setq sql-mode-hook nil)

(add-hook! sql-mode
 :append
 (map! :map sql-mode-map
       :localleader
       "'" #'kev/start-duck
       (:prefix ("r" . "repl")
                "q" (cons "quit"
                          (lambda () (interactive)
                            (process-send-string kev/duckp ".quit\n"))))
       (:prefix ("e" . "Eval")
                "r" (cons "shell send region or paragraph" #'kev/shell-send-))))
#+end_src
** org
#+begin_src elisp
(after! org
  ;;(define-key org-mode-map (kbd "C-c f") #'org-babel-execute-src-block)

  ;; Including =org-tempo= restores the =<s=-style easy-templates that were
  ;; deprecated in Org 9.2.
  (require 'org-tempo)

  ;; start everything folded
  (setq org-startup-folded 't)
  ;; code blocks font
  (setq org-src-fontify-natively t)
  (setq org-src-tab-acts-natively t))

(defun is-file-in-subdirectory (subdir)
  "Check if the current buffer's file is in a specified SUBDIR."
  (let ((current-file (buffer-file-name)))
    (when current-file
      (string-prefix-p (expand-file-name subdir)
                       (expand-file-name current-file)))))

(after! org
  (map! :map evil-org-mode-map
        :m "C-k" #'evil-previous-visual-line
        :m "C-j" #'evil-next-visual-line
        :m "gj" #'evil-next-visual-line
        :m "gk" #'evil-previous-visual-line
        :localleader
        "'"  #'org-edit-special
        (:prefix "g" "b" #'org-mark-ring-goto)))

(set-company-backend! 'text-mode 'company-yasnippet)

;; general org settings
;; makes a clearer distinction between sub-bullets
(use-package! org-bullets-mode
  :hook org-mode)
#+end_src

wat?

#+begin_src elisp
(defun kev/org-archive-subtree
  (org-copy-subtree))
#+end_src

** org babel
#+begin_src elisp
;; org babel stuff
(after! org
  (require 'ob-clojure)
  (setq org-babel-clojure-backend 'cider)

  (add-to-list 'org-babel-default-header-args
             '(python . (:results . "output"))))

(defvar-local kev-cider-session nil)

(defun kev/select-option (prompt alist)
  (require 'ivy)
  (cdr
   (assoc (ivy-read prompt alist :require-match t)
          alist)))

(defun kev/select-session ()
  (require 'ivy)
  (let* ((sessions (cider-sessions))
         (_ (unless sessions (error "no repl sessions found! start one first")))
         (session (if (member kev-cider-session sessions)
                      kev-cider-session
                    (setq kev-cider-session
                          (if (cdr sessions)
                              (kev/select-option
                               "pick session: "
                               (seq-map
                                (lambda (sesh)
                                  (cons (buffer-name (cadr sesh))
                                        (cadr sesh)))
                                sessions))
                            (setq kev-cider-session (cadar sessions)))))))
    session))

(after! ob-clojure
  (defun org-babel-execute:clojure (body params)
    "Execute a block of Clojure code with Babel and nREPL."
    (require 'cider)

    (setq kev-cider-session nil)

    (let* ((session (kev/select-session))
           (response (cider-nrepl-sync-request:eval
                      (org-babel-expand-body:clojure body params)
                      session)))
      (nrepl-dbind-response response (out status)
        (print
         (list "cider session:" session
               "params:" params
               "result" response))
        out))))
#+end_src

** org-roam

org-roam setup and shortcuts

*** subnodes
- subnode extention
  - problem statement: explosion of one flat directory is untenable especially when you want to look for something within a specific directory. Still want to preserve roam's ultimate freedom and linking though.
  - implementation
    - ONLY thing added is the property =:SUBNODE_OF: <org_id>= which will mark subnodes and find those to search & exclude them from regular search, exept by parent.
    - parents are found by just finding all ids that appear in a :subnode_of:
    - have to change regular finds to ignore subnodes now
  - TODO
    - [ ] subnode links, depricate old shit
    - [ ] make roam buffer section for subnodes
    - [ ] allow todo items. have all things under a node cross-noted with TODO show up in the roam buffer
    - [X] allow for multiple subnode_of entries so you can "file" something under two things
    - [X] hide sub nodes when they have sub nodes.
      - you'd have recursive loop if there are more subnodes, or a defaulted selection of the node itself (maybe pretty printed somehow?).
        Then it'd work for inserting / finding both nodes and subnodes.
      - should add the parent prefix so I can give no context titles. or just give no-context alias
      - but then creating subnodes.. I guess could also use this flow bc it allows toplevel

#+begin_src elisp
;; -*- lexical-binding: t; -*-

(defun kev/complement (fn)
  (lambda (&rest args)
    (not (apply 'funcall fn args))))

(defun kev/roam-subnode-get-parent-ids (node)
  (let ((subnode-of-val (->> node
                             (org-roam-node-properties)
                             (assoc-string "SUBNODE_OF")
                             (cdr))))
    (when subnode-of-val
      (->> subnode-of-val
           (split-string)))))

(defun kev/roam-subnode-get-parent (node)
  "actually just gets the first parent id"
  (car (kev/roam-subnode-get-parent-ids node)))

(defun kev/roam-subnode-get-all-parent-ids ()
  (seq-reduce
   (lambda (ids node)
     (let ((subnode-of (thread-last node
                                    (org-roam-node-properties)
                                    (assoc-string "SUBNODE_OF")
                                    (cdr))))
       (if (and subnode-of
                (not (member subnode-of ids)))
           (cons subnode-of ids)
         ids)))
   (org-roam-node-list)
   nil))

(defun kev/roam-subnode-find-parent ()
  (let ((parent-ids (kev/roam-subnode-get-all-parent-ids)))
    (org-roam-node-read nil
                        (lambda (node)
                          (member (org-roam-node-id node) parent-ids))
                        nil
                        'require-match
                        "parend node: ")))

(defun kev/roam-subnode-filter-subnodes (parent-node)
  (lambda (fnode)
    (member (org-roam-node-id parent-node)
            (kev/roam-subnode-get-parent-ids fnode))))

;;;;;;;;;;;;;;;; main interface ;;;;;;;;;;;;;;;

(defun kev/test ()
  (interactive)
  (print (org-entry-get nil "ITEM")))

(defun kev/roam-subnode-find-non-subnodes ()
  (interactive)
  (funcall #'org-roam-node-find nil nil (kev/complement #'kev/roam-subnode-get-parent)))

(defun kev/prn (&rest args)
  (print args))

(defun kev/roam-subnode-find-node (&optional current-node require-match)
  "I think I can basically delete this"
  (interactive (list nil))
  (require 'org-roam-node)
  ;; (kev/prn  "got node" (when current-node (org-roam-node-title current-node)))
  (if current-node
      (let ((found (cl-remove-if-not
                    (kev/roam-subnode-filter-subnodes current-node)
                    (org-roam-node-list))))
        (if (car found)
            ;; if there are subnodes,
            (let ((rnode
                   (org-roam-node-read nil
                                       (kev/roam-subnode-filter-subnodes current-node)
                                       nil
                                       require-match
                                       )))
              (if (org-roam-node-id rnode)
                  (kev/roam-subnode-find-node rnode)
                current-node))
          current-node))
    (kev/roam-subnode-find-node
     (org-roam-node-read nil
                         (kev/complement #'kev/roam-subnode-get-parent)))))

(defun kev/roam-subnode-create (parent)
  (interactive (list (org-roam-node-read nil nil nil 'require-match)))
  (let ((new-id (org-id-get-create)))
    ;; eventially only want this & to migrate
    (org-roam-add-property (org-link-make-string (concat "id:" (org-roam-node-id parent))
                                                 (org-roam-node-title parent))
                           "PARENT_LINKS")
    (org-roam-add-property (org-roam-node-id parent) "SUBNODE_OF")
    ;; subnode of title purely for visibility, not used for anything
    (org-roam-add-property (org-roam-node-title parent) "SUBNODE_OF_TITLE")
    ))

(defun kev/roam-subnode-find ()
  (interactive)
  (require 'org-roam-node)
  (org-roam-node-visit (kev/roam-subnode-find-node)))

(defun kev/roam-subnode-insert ()
  (interactive)
  (let ((node (kev/roam-subnode-find-node)))
    (org-roam-node-insert (lambda (fnode) (equal fnode node)))))


;;;;;;;;;;;;;;;;;;;;;;; main roam config ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO do the file resize thing and visual line mode
;; to org roam dir
;; org roam to display in same window
(add-to-list 'display-buffer-alist '("\\*org-roam.*\\*" . (display-buffer-reuse-window display-buffer-same-window)))
(add-to-list 'display-buffer-alist '("\\*lsp-help\\*" . (display-buffer-reuse-window display-buffer-same-window)))

(defvar kev/org-roam-node-subnode-name-cache (make-hash-table :test 'equal)
  "Cache for storing results of `org-roam-node-kev-subnode-format'.")

(defun kev/subnode-parents (node &optional so-far)
  (let ((parent-node (thread-last node
                                  (org-roam-node-properties)
                                  (assoc-string "SUBNODE_OF")
                                  (cdr)
                                  (org-roam-node-from-id))))
    (if parent-node
        (cons parent-node
              (kev/subnode-parents parent-node))
      nil)))

(defun kev/subnode-tree (node)
  "returs list of acestor trees where each car is parent and cdr is the list of ancestors"
  (cons node
        (thread-last node
                     (org-roam-node-properties)
                     (assoc-string "SUBNODE_OF")
                     (cdr)
                     ((lambda (s) (when s (s-split " " s))))
                     (mapcar #'org-roam-node-from-id)
                     (cl-remove-if 'not)
                     (mapcar (lambda (parent)
                               (kev/subnode-tree parent))))))

(defun subnode-flat-parent-tree (tree)
  (or
   (thread-last (cdr tree)
                (seq-mapcat (lambda (pt)
                              (mapcar (lambda (p) (cons (car tree)
                                                        p))
                                      (subnode-flat-parent-tree pt)))))
   (list (list (car tree)))))

;; (thread-last "c21ebe89-5182-4fbd-87f9-ef5e4f14e420"
;;              (org-roam-node-from-id)
;;              (kev/subnode-tree)
;;              ;; (subnode-paths)
;;              (subnode-flat-parent-tree)
;;              (car)
;;              (mapcar #'org-roam-node-title)
;;              )

(defun kev/subnode-formatted-parents (node)
  (thread-last (when node (kev/subnode-tree node))
               (cdr)
               (mapcar (lambda (pt)
                         (thread-last pt
                                      (subnode-flat-parent-tree)
                                      ;; first path of each parent
                                      (car)
                                      (mapcar #'org-roam-node-title)
                                      (s-join " -> "))))
               (s-join "|")))


(after! org-roam

  (cl-defmethod org-roam-node-kev-parent-path ((node org-roam-node))
    "would be used in org-roam-node-display-template by setting it to \"${kev-subnode-format}\""
    (let ((node-id (org-roam-node-id node)))
      (or (gethash node-id kev/org-roam-node-subnode-name-cache)
          (let ((result
                 (kev/subnode-formatted-parents node)))
            (puthash node-id result kev/org-roam-node-subnode-name-cache)
            result))))

  (setq org-roam-node-display-template (concat (propertize "${title:*}" 'face 'outline-1)
                                               (propertize "${kev-parent-path:*}" 'face 'font-lock-comment-face)
                                               ))
  ;; TODO build cache eagerly
  (setq kev/org-roam-node-subnode-name-cache (make-hash-table :test 'equal))

  (defun kev/backlink-is-daily? (backlink)
    (require 'org-roam-dailies)
    (thread-last backlink
                 (org-roam-backlink-source-node)
                 (org-roam-node-file)
                 (org-roam-dailies--daily-note-p)))

  (cl-defun kev/subnodes-section (node)
    "subnodes section"
    ;; TODO sort?
    (when-let ((subnodes (cl-remove-if-not
                          (kev/roam-subnode-filter-subnodes node)
                          (org-roam-node-list))))
      (magit-insert-section (org-roam-backlinks)
        (magit-insert-heading "Subnodes:")
        (dolist (subnode subnodes)
          (org-roam-node-insert-section
           :source-node subnode
           :point (org-roam-node-point subnode)
           ;; note can fill in when we have something real
           :properties nil ;; (org-roam-backlink-properties backlink)
           ))
        (insert ?\n))))

  (defun kev/roam-dailies-section (node)
    "newest->oldest dailies"
    (cl-letf (((symbol-function 'org-roam-backlinks-sort) (lambda (a b)
                                                            ;; just look at filename for dailiy check
                                                            (string< (org-roam-node-file (org-roam-backlink-source-node b))
                                                                     (org-roam-node-file (org-roam-backlink-source-node a))))))
      (org-roam-backlinks-section node :show-backlink-p #'kev/backlink-is-daily?)))

  (setq org-roam-mode-sections (list
                                #'kev/subnodes-section
                                ;; ordered dailies
                                #'kev/roam-dailies-section
                                ;; non-dailies
                                `(org-roam-backlinks-section :show-backlink-p ,(kev/complement #'kev/backlink-is-daily?))
                                'org-roam-reflinks-section))
  )

(kev/comment

 ;; nah this don't do shit really.
 ;; interesting though would be to propertize the parents or align them?
 (setq org-roam-node-annotation-function (lambda (n)
                                           (concat (propertize " "  'display '(space :align-to center))
                                                   (org-roam-node-file n))))

 (org-roam-node-read)
 (lambda (n)
   (thread-last (kev/subnode-tree n)
                (cdr)
                (mapcar (lambda (pt)
                          (car (subnode-paths pt))))
                (cons "")
                (cl-reduce (lambda (&optional a b)
                             (concat a
                                     (propertize "\n " 'display '(space :align-to center))
                                     b))
                           )))

 (concat "a " "b" "c")


 (org-roam-node-from-id "")

 (s-join "poop" (list "a-" "-b" "-c"))
 ;; NOTE:
 ;; idea -- add post hook to org roam db sync to update the subnode titles
 ;; OR -- cache around subnode format, but idk how to invalidate cache except manually
 (org-roam-db-sync)
 (reverse (list 1 2 3))
 (org-roam-db-update-file)
 (org-roam-node-find)
 (org-roam-node-list)
 (org-roam-id-find "2bb8fe67-0197-422e-a4a9-f392764bbceb")
 kev/org-roam-node-subnode-name-cache (make-hash-table :test 'equal)

 (setq kev/org-roam-node-subnode-name-cache (make-hash-table :test 'equal))

 (setq org-roam-node-display-template "${title}")

 (org-roam-node-title)

 (mapcar
  #'org-roam-node-title
  (kev/subnode-parents
   (org-roam-node-from-id "e29a1f5a-0a1d-4616-8c41-9320e501cdbf")))

 (org-roam-node-read--to-candidate
  (org-roam-node-from-id "2bb8fe67-0197-422e-a4a9-f392764bbceb")
  (org-roam-node--process-display-format "${kev-subnode-format}"))

 )

;; map org roam everywhere to these autoloads
(map! (:prefix ("C-c n" . "Org Roam")
               (:prefix ("s" . "sub-node")
                        "i" #'kev/roam-subnode-insert
                        "c" #'kev/roam-subnode-create
                        "f" #'kev/roam-subnode-find)
               "f" #'org-roam-node-find
               "d" #'org-roam-dailies-goto-today))

(after! org-roam

  (map! (:map org-mode-map
              (:prefix ("C-c n" . "Org Roam")
                       (:prefix ("s" . "sub-node")
                                "i" #'kev/roam-subnode-insert
                                "c" #'kev/roam-subnode-create
                                "f" #'kev/roam-subnode-find)
                       "c" #'org-id-get-create
                       "i" #'org-roam-node-insert
                       "r" '("org-roam-buffer-display-dedicated" .
                             (lambda ()
                               (interactive)
                               ;; sets up prefix arg so it uses current node
                               ;; number `1' is not specific here
                               (setq current-prefix-arg '(1))
                               (call-interactively #'org-roam-buffer-display-dedicated)))
                       "d" #'org-roam-dailies-goto-today
                       "a" #'org-roam-alias-add)))

  (defun kev/next-non-whitespace ()
    (interactive)
    (skip-syntax-forward " >"))

  ;; TODO: make this only go up a few levels of indentation rather than to zero.
  ;; should be pretty easy
  (defun kev/org-roam-preview ()
    "default is `org-roam-preview-default-function' This changes to just line"
    (let* ((start-indent (current-indentation))
           (beg (save-excursion
                  (while (not (or (= 0 (current-indentation))
                                  ;; go up two levels of indent
                                  (<= (current-indentation) (- start-indent 2))))
                    (evil-previous-line))
                  (beginning-of-line)
                  (point)))
           (end (save-excursion
                  ;; so it collects heading stuff. Maybe should remove
                  (if (= ?* (char-after (line-beginning-position)))
                      (org-end-of-subtree)
                    (progn
                      (evil-next-line)
                      (while (and (not (<= (current-indentation) start-indent))
                                  (not (<= (point-max) (line-end-position))))
                        (evil-next-line)
                        (evil-beginning-of-line)
                        (kev/next-non-whitespace)
                        )
                      (evil-beginning-of-line)))
                  (point))))
      (string-trim (concat (buffer-substring-no-properties beg end) "\n"))))
  ;; makes roam stuff prettier
  (add-hook! 'org-roam-mode-hook
    (kev-set-visual-columns))


  ;; If you're using a vertical completion framework, you might want a more informative completion interface
  ;; (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  (org-roam-db-autosync-mode 1)

  ;; define some keys everywhere
  (setq org-roam-v2-ack t
        org-roam-dailies-directory "daily/"
        org-roam-preview-function #'kev/org-roam-preview)
  org-roam-node-display-template "${title}"
  ;; this doesn't get called for some reason?
  ;; I think ivy ignores it for some reason
  ;; see `ivy-completing-read'?
  org-roam-node-annotation-function (lambda ()
                                      (message "calling annotation!")
                                      (let ((parent-node (thread-last node
                                                                      (org-roam-node-properties)
                                                                      (assoc-string "SUBNODE_OF")
                                                                      (cdr)
                                                                      (org-roam-node-from-id))))
                                        (if parent-node
                                            (concat "parent: " (org-roam-node-title parent-node))
                                          "")))
  ;; org-roam-node-formatter
  ;; I'd imagine this could be used if we want to prefix titles of subnodes with parent.
  ;; then when you insert the node, you'd undo the prefix when inserting.
  ;; then you don't have to worry about having super generic titles
  )

#+end_src

*** general setup
#+begin_src elisp
(defun kev-set-visual-columns ()
  (visual-line-mode 1)
  (visual-fill-column-mode 1)
  (after! visual-fill-column
    (setq visual-fill-column-width 80
          ;; idk if I like this yet
          visual-fill-column-center-text nil)))

(add-hook! 'org-mode-hook :append
           ;; org roam should fix column width!
  (when (is-file-in-subdirectory org-roam-directory)
    (require 'org-roam)
    (kev-set-visual-columns)))

(use-package! org-roam
  :after org
  ;; :after org
  ;; this loads eagerly. The following would load it during idle time
  )
#+end_src
** org biblio
TODO
- [ ] autocomplete for org-ref links

org ref seems better than citar! bc
- the open display is less sexy, though more functional bc you memorize the keys
- has option to go to bibtex entry
#+begin_src elisp

;; org-ref stuff
(setq bibtex-completion-bibliography '("~/Desktop/bibliography/refs.bib")
      ;; NOTE needs the trailing slash! idk why the fudge
      bibtex-completion-library-path '("~/Desktop/bibliography/pdfs/")

      bibtex-completion-additional-search-fields '(keywords)
      ;; bibtex-completion-display-formats
      ;; '((article       . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${journal:40}")
      ;;     (inbook        . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} Chapter ${chapter:32}")
      ;;     (incollection  . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
      ;;     (inproceedings . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
      ;;     (t             . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*}"))
      bibtex-completion-notes-path nil
      )
(use-package! org-ref
  :defer-incrementally org-roam)

;; org roam bibtex stuff
(use-package! org-roam-bibtex
  :after org-roam)
(after! org-roam-bibtex
  (require 'org-ref)
  (setq orb-roam-ref-format 'org-ref-v3))
(add-hook! org-mode
  ;; could maybe restrict this to org-roam-dir but whatever
  (org-roam-bibtex-mode 1)
  (setq-local company-minimum-prefix-length 0))


;; I think citar can get better than org ref at some point but just not today
;;
;; (use-package! citar-org-roam
;;   :after (citar org-roam))
;; (after! (org-roam citar)
;;   (require 'citar-org-roam)
;;   (require 'org-roam-bibtex))
;; (after! citar-org-roam
;;   (citar-org-roam-mode)
;;   (citar-register-notes-source
;;    'orb-citar-source (list :name "Org-Roam Notes"
;;                            :category 'org-roam-node
;;                            :items #'citar-org-roam--get-candidates
;;                            :hasitems #'citar-org-roam-has-notes
;;                            :open #'citar-org-roam-open-note
;;                            :create #'orb-citar-edit-note
;;                            :annotate #'citar-org-roam--annotate))
;;   (add-hook! org-mode 'citar-capf-setup)
;;   (setq citar-notes-source 'orb-citar-source
;;         citar-bibliography '("~/Desktop/bibliography/refs.bib")
;;         citar-library-paths '("~/Desktop/bibliography/pdfs/")
;;         citar-notes-paths (list (concat org-roam-directory "/citar/"))
;;         citar-file-note-extensions '(".org")))
;; (use-package! citar-embark
;;   :after citar embark
;;   :no-require
;;   :config (citar-embark-mode))



#+end_src
** rust

#+begin_src elisp
(use-package! yasnippet
  :hook ((lsp-mode . yas-minor-mode)))

;; (rustic-cargo-current-test)

(add-hook! rustic-mode
  (lsp)
  (lsp-mode 1)
  (yas-minor-mode 1)
  (read-only-mode 0)
  :local
  (kev-setq-local
   lsp-rust-analyzer-display-lifetime-elision-hints-enable "always"
        lsp-rust-analyzer-display-lifetime-elision-hints-use-parameter-names t
        lsp-headerline-breadcrumb-enable nil
        lsp-ui-sideline-enable t
        lsp-ui-sideline-show-code-actions t
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-hover t
        lsp-signature-auto-activate t
        lsp-signature-render-documentation t
        lsp-ui-doc-enable nil
        lsp-ui-doc-show-with-cursor nil
        lsp-ui-doc-position 'at-point

        lsp-completion-show-detail t
        lsp-completion-show-kind t
        rustic-default-test-arguments "--benches --tests --all-features --nocapture")

  ;; TODO make local to rust mode
  (map! :map lsp-command-map
        "t"  #'lsp-rust-analyzer-related-tests
        "dd" #'lsp-rust-analyzer-open-external-docs))
#+end_src

#+RESULTS:

** elisp

#+begin_src elisp
;; gotos
(use-package! elisp-slime-nav
  :defer-incrementally (elisp-mode ielm))
(after! elisp-slime-nav
  (turn-on-elisp-slime-nav-mode))

(defun kev/eval-to-comment ()
  (interactive)
  (let ((value (eval (preceding-sexp))))
    (sp-end-of-sexp)
    (forward-char)
    (insert (format "\n;; => %S" value))))

;; (add-hook! (emacs-lisp-mode ielm-mode))
(map! :mode emacs-lisp-mode
      :localleader
      "e;" #'kev/eval-to-comment
      "gg" #'elisp-slime-nav-find-elisp-thing-at-point
      "gb" #'pop-tag-mark)
#+end_src
** Ruby
#+begin_src elisp
(map! :mode ruby-mode
      :localleader
      :prefix ("g". "goto")
      "g" #'robe-jump
      :prefix ("e" . "eval..")
      "b" #'ruby-send-buffer
      "d" #'ruby-send-definition
      "f" #'ruby-send-block
      "e" #'ruby-send-last-stmt
      "r" #'ruby-send-region)

(remove-hook 'robe-mode-hook 'ac-robe-setup)

(add-hook! 'ruby-mode-hook
  (after! company
    (push 'company-robe company-backends)))
#+end_src

#+RESULTS:

** JavaScript n TypeScript

#+begin_src elisp
;; lsp uses typescript-language-server
;; with npm i -g typescript-language-server
;; (add-hook! typescript-mode
;;   (lsp)
;;   (lsp-mode 1)

;;   (setq typescript-indent-level 2))

#+end_src

#+RESULTS:

update: should really just use emacs' lsp-mode for this

i think this should be handled so commented, hook adding issues maybe
#+begin_src elisp
;; (add-hook! js2-mode
;;            (lsp)
;;            (lsp-mode 1))

;; (map! :mode js2-mode
;;       :localleader
;;       (:prefix ("g" . "goto...")
;;       "g" 'js2-jump-to-definition
;;       "b" #'pop-tag-mark))

;; for skewer, like a repl type thing for js
;; (map! :mode skewer
;;       (:prefix (",e" . "skewer eval")
;;        "d" 'skewer-eval-defun))
#+end_src



#+RESULTS:

** python
#+begin_src elisp

(defvar kev/py-shell-interpreter "python3"
  "no spaces allowed! a restriction of python.el")

(defvar kev/py-shell-dir "/ssh:kkrausse@diesel2:/home/kkrausse/repos/kkrausse/memory-mistral")

;; (add-to-list 'display-buffer-alist '("\\*org-roam.*\\*" . (display-buffer-reuse-window display-buffer-same-window)))

;; NOTE: may have to look back into run-python to see if I need to enable remote local variables or something
(defun kev/python-remote-shell ()
  (interactive)
  (let ((shell-dir kev/py-shell-dir)
        (py-interp kev/py-shell-interpreter))
    (with-current-buffer (find-file-noselect shell-dir)
      (with-connection-local-variables
       (message (concat "opening python shell in\n"
                        shell-dir
                        "cmd:\n"
                        py-interp))
       (run-python py-interp))))
  (with-current-buffer (python-shell-get-buffer)
    (setq-local comint-scroll-to-bottom-on-output 'others))
  (display-buffer (python-shell-get-buffer)
                  '(display-buffer-reuse-window
                    display-buffer-use-least-recent-window)))


(defun format-python-print (python-code)
  "Format PYTHON-CODE as a Python print statement, properly escaping single quotes."
  (let ((escaped-code (replace-regexp-in-string "'" "\\\\'" python-code)))
    (format "print('''%s...''')" escaped-code)))

(kev/comment
 (print
  (format-python-print
   "print('what is this')")))

(defun kev/python-shell-send-string (body)
  (require 'ob-python)
  (let ((body
         (format "\
%s
%s
"
                 (format-python-print body)
                body)))
    (python-shell-send-string body))


  ;; strategy of just writing to buffer kinda weird and doesn't print outputs
  ;; (with-current-buffer (python-shell-get-buffer)
  ;;   (end-of-buffer)
  ;;   (insert body)
  ;;   (comint-send-input))
  )

(defun kev/python-shell-send-region (start end)
  (kev/python-shell-send-string (buffer-substring-no-properties start end)))

;; FIXME: this doesn't work when there's like empty spaces in the function sometimes?
;; I think it has to do with which line you start on, not with the nav-...-statement stuff
(defun kev/python-shell-send-toplevel ()
  (interactive)
  (let ((start (point)))
    (save-excursion
      (kev/python-shell-send-region
       (progn (python-nav-beginning-of-statement)
              (while (> (current-indentation) 0)
                (python-nav-backward-statement))
              (point-marker))
       (progn (goto-char start)
              (python-nav-end-of-statement)
              (unless (= (line-end-position) (buffer-end 1))
                      (python-nav-forward-statement))
              (while (and (> (current-indentation) 0)
                          (not (= (line-end-position) (buffer-end 1))))
                (python-nav-forward-statement))
              ;; in case you're at the end of the buffer, don't go back
              (unless (= (line-end-position) (buffer-end 1))
                      (python-nav-backward-statement))
              (python-nav-end-of-statement)
              (min (buffer-end 1)
                   (point-marker)))))))

(defun kev/python-shell-send-paragraph()
  (interactive)
  (let ((start (point)))
    (save-excursion
      (kev/python-shell-send-region
       ;;python-shell-send-region
       (progn (backward-paragraph)
              (forward-char)
              (python-nav-beginning-of-statement))
       (progn (goto-char start)
              (forward-paragraph)
              (backward-char)
              (python-nav-end-of-statement)
              (min (buffer-end 1)
                   (point-marker)))))))

(after! python
  (setq python-shell-prompt-detect-failure-warning nil))

(add-hook! 'python-mode-hook
  (map! :map python-mode-map
        :localleader
        "'" #'kev/python-remote-shell
        (:prefix ("r" . "repl")
                 "q" (cons "quit"
                           (lambda () (interactive)
                             (kev/python-shell-send-string "quit()"))))
        (:prefix ("e" . "Eval")
                 "b" #'python-shell-send-buffer
                 "r" (cons "region or paragraph"
                      (lambda (start end)
                        (interactive (list (region-beginning) (region-end)))
                        (if (region-active-p)
                            (python-shell-send-region start end)
                          (kev/python-shell-send-paragraph))))
                 "d" #'kev/python-shell-send-toplevel)))
#+end_src

#+RESULTS:

** Clojure

nice keybindings

#+begin_src elisp
(setq kevin-clojure-playbook
      '(("portal" . "(do (require 'portal.api) (portal.api/open) (add-tap #'portal.api/submit))")
        ("sync deps" . "((requiring-resolve 'clojure.repl.deps/sync-deps) :aliases [:test :dev :local-dev])")
        ("prn space" . "(doseq [_ (range 40)] (prn \"\"))")
        ("humane test output" . "((requiring-resolve 'pjstadig.humane-test-output/activate!))")
        ("warn on reflection" . "(set! *warn-on-reflection* true)")))

(defun kevin-clojure-playbook (&optional output-to-current-buffer)
  "evaluate something from the playbook (w/ cider)"
  (interactive "P")
  (let ((cmd (completing-read "clj cmd: "
                              kevin-clojure-playbook
                              nil
                              t
                              nil
                              'kevin-clojure-playbook)))
    (cider-interactive-eval (cdr (assoc cmd kevin-clojure-playbook))
                            nil
                            (cider-defun-at-point 'bounds)
                            (cider--nrepl-pr-request-map))))

(defun kev-format-form (beg end)
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (save-excursion
                   (let ((end (progn (end-of-defun)
                                     (point))))
                     (clojure-backward-logical-sexp)
                     (list (point) end)))))
  (save-excursion
    (clojure-align beg end)
    (lsp-format-region beg end)))

(add-to-list 'display-buffer-alist '("\\*cider-error\\*" . (display-buffer-reuse-window display-buffer-same-window)))
(add-hook! clojure-mode
           ;;(aggressive-indent-mode) this shit so slow :(
           (hs-minor-mode 1)

           (setq cider-comment-prefix "(comment\n"
                 cider-comment-continued-prefix "  "
                 indent-region-function nil
                 cider-comment-postfix ")"

                 clojure-toplevel-inside-comment-form t
                 ;; code alignment
                 clojure-align-forms-automatically t

                 ;; because lsp indent is incredibly annoying for clojure
                 indent-region-function nil
                 cider-auto-jump-to-error nil
                 cider-auto-select-error-buffer nil
                 )


           (defun kev-format-buffer ()
             (interactive)
             (save-excursion
               (lsp-format-buffer)
               (clojure-align (point-min) (point-max))))

           (define-clojure-indent
             (into 1)
             (do-template 2)
             (sc.api/letsc 1)
             (macrolet '(1 ((:defn)) nil)))
           )

(define-advice aggressive-indent--indent-if-changed (:around (orig-fun buffer) aggressive-indent-advice)
  (when (not (with-current-buffer buffer
               (evil-insert-state-p)))
    (funcall orig-fun buffer)))

;; prettier indentation!
(define-advice cider-maybe-insert-multiline-comment
    (:around (orig-fun result comment-prefix continued-prefix comment-postfix) cider-comment-advice)
  (funcall orig-fun result comment-prefix continued-prefix comment-postfix)
  (save-excursion
    (let ((end (point)))
      (sp-backward-sexp)
      (kev-indent (point) end))))

(map! :mode clojure-mode
      :localleader
      "e." (lambda (&optional output-to-current-buffer)
             (interactive "P")
             (save-excursion
               (goto-char (- (cadr (cider-list-at-point 'bounds)) 1))
               (cider-eval-last-sexp output-to-current-buffer)))
      "ef" #'cider-eval-defun-at-point
      "ep" #'kevin-clojure-playbook
      "e;" (lambda (&rest output-to-current-buffer)
             (interactive "P")
             (save-excursion
               (goto-char (- (cadr (cider-list-at-point 'bounds)) 0))
               (cider-pprint-form-to-comment 'cider-last-sexp nil)))
      "et" (lambda (&optional output-to-current-buffer)
             "run toplevel as clojure test; return report"
             (interactive "P")
             (cider-interactive-eval (concat "("
                                             "binding #?(:clj [clojure.test/*report-counters* (ref clojure.test/*initial-report-counters*)] :cljs [])"
                                             "(let [defun-to-test"
                                             (cider-defun-at-point)
                                             "]"
                                             "(clojure.test/test-var defun-to-test)"
                                             "(clojure.test/test-vars [\n"
                                             "])"
                                             "#?(:clj (prn @clojure.test/*report-counters*))"
                                             "#?(:clj @clojure.test/*report-counters*)"
                                             ")"
                                             ")")
                                     nil
                                     (cider-defun-at-point 'bounds)
                                     (cider--nrepl-pr-request-map)))
      "en" #'cider-eval-ns-form
      "="  #'kev-format-form
      "ip" #'(lambda () (interactive) (insert "clojure.pprint/pprint")))

(defun cider-jack-in-babashka ()
  "Start an babashka nREPL server for the current project and connect to it."
  (interactive)
  (let* ((default-directory (project-root (project-current t)))
         (process-filter (lambda (proc string)
                           "Run cider-connect once babashka nrepl server is ready."
                           (when (string-match "Started nREPL server at .+:\\([0-9]+\\)" string)
                             (cider-connect-clj (list :host "localhost"
                                                      :port (match-string 1 string)
                                                      :project-dir default-directory)))
                           ;; Default behavior: write to process buffer
                           (internal-default-process-filter proc string))))
    (set-process-filter
     (start-file-process "babashka" "*babashka*" "bb" "--nrepl-server" "0")
     process-filter)))
#+end_src

#+RESULTS:
: cider-jack-in-babashka

lsp utils

#+begin_src elisp
;; develop on clojure-lsp
;; "~/Documents/me/misc/clojure-lsp/clojure-lsp"
;; else just "clojure-lsp"
(setq lsp-clojure-custom-server-command nil)

(defun lsp-clojure-nrepl-connect ()
  "Connect to the running nrepl debug server of clojure-lsp."
  (interactive)
  (let ((info (lsp-clojure-server-info-raw)))
    (save-match-data
      (when-let (port (and (string-match "\"port\":\\([0-9]+\\)" info)
                           (match-string 1 info)))
        (cider-connect-clj `(:host "localhost"
                             :port ,port))))))
#+end_src

cider configs

#+begin_src elisp
;;(setq cider-comment-prefix "\n;; => ")
(setq kev-clojure-cli-param-hist '("-M:test:dev:local-dev"
                                   "-M:cljs"
                                   "-X:local-dev:cljs"
                                   "-M:local-dev:server:cljs # clj(s) projects "
                                   "-A:test:dev:local-dev -m nrepl.cmdline --middleware '[cider.nrepl/cider-middleware]' --interactive --color # no reveal for java8"
                                   ))


(put 'cider-custom-cljs-repl-init-form 'safe-local-variable 'identity)
(use-package! cider
  ;; for some reason, this works. But after! doesn't work.
  ;; neither does `:hook (clojure-mode . cider-mode)`. Both cause the doom module
  ;; config to be ignored. This doesn't though
  :after-call clojure-mode-hook
  :config
  (setq cider-comment-prefix "\n;; => "
        cider-repl-buffer-size-limit 100)


        ;; fix shadow to not auto-evaluate forms!
        ;; well, can adjust this. for now, keeping
        ;; BUT maybe it would be a good idea to actually
        ;; look at shadow.cljs.devtools.api/nrepl-select
        ;; (setcar
        ;;  (cdr (seq-find (lambda (e)
        ;;                 (eq 'shadow (car e)))
        ;;                 cider-cljs-repl-types))
;;         'cider-shadow-select-cljs-init-form)


  ;; this is to fix the cider jack in to by my own thing because they changed some
  ;; version and got rid of =cider-clojure-cli-parameters=
  (setq cider-jack-in-dependencies nil)
  (setq cider-jack-in-auto-inject-clojure nil)
  (setq cider-inject-dependencies-at-jack-in t)
)

  ;; NOTE: instead set cider-jack-in-cmd with .dir-locals.el !!!
  ;; see how ppl do it:
  ;; https://github.com/djblue/portal/blob/48bda9b9b59795802a18f301d982b1f41d0db3c6/.dir-locals.el#L1
  ;;

  ;; (define-advice cider-jack-in-params (:around (orig-fun project-type) jack-in-param-advice)
  ;;   (pcase project-type
  ;;     ('clojure-cli (ivy-read "clojure cli params: "
  ;;                             kev-clojure-cli-param-hist
  ;;                             :history 'kev-clojure-cli-param-hist))
  ;;     (_ (funcall orig-fun project-type))))
;; (define-advice cider-inject-jack-in-dependencies (:around (orig-fun global-opts params project-type &optional command)
;;                                                           inject-deps-advice)
;;   (pcase project-type
;;     ('clojure-cli params)
;;     (_ (funcall orig-fun global-opts params project-type command))))

;; cider window popup!
;;
;; use display-buffer-alist to fix what we do!
;; cider-repl-pop-to-buffer-on-connect is 'display-only
;; cider-repl-display-in-current-window
;; (cider-jack-in)
(setf (alist-get "\\*cider-repl.*" display-buffer-alist)
      '(display-buffer-use-least-recent-window))

(define-advice nrepl-start-server-process (:around (orig-fun directory cmd on-port-callback) nrepl-start-server-process-advice)
  ;; insert prefix because sdkman doesn't insert the environment in emacs automatically
  ;; idk how to set it for the current emacs shell. may not be possible
  ;; was: "source \"$HOME/.sdkman/bin/sdkman-init.sh\" && { echo \"no\n\" | sdk env || echo 'no .sdkman?' } && sdk c java && "
  (let ((cmd-prefix "source \"$HOME/.sdkman/bin/sdkman-init.sh\" && echo \"no\\n\" | sdk c java && "))
    (funcall orig-fun directory (concat cmd-prefix cmd) on-port-callback)))
#+end_src

#+RESULTS:
: nrepl-start-server-process@nrepl-start-server-process-advice

** lsp
for code alignment, look at [[https://github.com/clojure-emacs/clojure-mode#indentation-of-macro-forms][clojure mode docs]] and at [[https://docs.cider.mx/cider/indent_spec.html][cider docs]]

#+begin_src elisp
(add-hook! 'lsp-mode-hook

           (lsp-ui-mode 1)
           ;; I don't think these are required?
           ;; (evil-set-command-property 'evil-ex-search-next :jump nil)
           ;; (evil-set-command-property 'evil-ex-search-backward :jump nil)
           (map! :map lsp-command-map
                 ;; TODO maybe prefix will fix lack of docs
                 "gb" #'xref-go-back
                 "gf" #'xref-go-forward
                 "d" #'lsp-ui-doc-glance)
           (map! "s-l" lsp-command-map)

           (lsp-diagnostics-mode 0)

           ;; TODO
           ;; look at lsp--default-directory-for-connection
           ;; how to lsp thing is set up and where it gets the config
           (setq lsp-ui-doc-position 'at-point
                 lsp-enable-symbol-highlighting 't
                 ;; perf stuff
                 lsp-file-watch-threshold 10000
                 gc-cons-threshold (* 100 1024 1024)
                 read-prcess-output-max (* 1024 1024)
                 lsp-ui-doc-enable nil
                 lsp-ui-doc-position 'at-point
                 lsp-headerline-breadcrumb-enable nil
                 lsp-ui-sideline-enable nil
                 lsp-ui-sideline-show-code-actions nil
                 lsp-modeline-diagnostics-enable nil

                 ;; focus help window when it shows up
                 help-window-select t

                 ;; change to locally do clojure lsp
                 lsp-clojure-custom-server-command '("zsh" "-c" "clojure-lsp")

                 ;;;; Xref / definition stuff
                 lsp-references-exclude-definition 't
                 ;; will treat everything as definition
                 lsp-xref-force-references 't
                 ;; Don't do this. it ignores multiples
                 xref-auto-jump-to-first-definition nil
                 xref-show-definitions-function 'xref-show-definitions-buffer-at-bottom

                 ;; ikd this was here before
                 cider-eldoc-display-for-symbol-at-point nil ;; disable cider eldoc
                 cider-repl-display-help-banner nil  ;;       disable help banner
                 )
           ;; don't know why I had these actually
           ;; necessary for showing references without relative path
           ;;
           ;; (setq ivy-xref-use-file-path t)
           ;; (setq xref-file-name-display 'project-relative)
           ;; (after! xref
           ;;   (setq xref-show-definitions-function #'xref-show-definitions-buffer-at-bottom))

           )

;; really disable cider eldoc
;; idk if this is actually needed anymore
;; (define-advice cider-eldoc-setup (:around (orig      -fun) cider-eldoc-advice)
;;   nil)

;; (add-hook! lsp-mode
;;   (turn-on-better-jumper-mode))

;; only done once, not every buffer
(after! lsp-mode
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]public\\'" "")
  (add-to-list 'lsp-file-watch-ignored-directories "[/\\\\]\\tmp\\'")
  )


;; makes so aggressive indent won't go until you exit insert mode
(define-advice aggressive-indent--indent-if-changed (:around (orig-fun buffer) aggressive-indent-advice)
  (when (not (with-current-buffer buffer
               (evil-insert-state-p)))
    (funcall orig-fun buffer)))
#+end_src


#+RESULTS:
: aggressive-indent--indent-if-changed@aggressive-indent-advice

** go
#+begin_src elisp

(add-hook! go-mode-hook)
#+end_src
** cue

#+begin_src emacs-lisp
(defconst cue-keywords
  '("package" "import" "for" "in" "if" "let"))

(defconst cue-constants '("null" "true" "false"))

(defconst cue-types
  '("int" "float" "string" "bool" "bytes"))

(defvar cue--font-lock-keywords
  `(("//.*" . font-lock-comment-face)
    (,(regexp-opt cue-constants 'symbols) . font-lock-constant-face)
    (,(regexp-opt cue-keywords 'symbols) . font-lock-keyword-face)
    (,(regexp-opt cue-types 'symbols) . font-lock-type-face)))

;;;###autoload
(define-derived-mode cue-mode prog-mode "CUE"
  "Major mode for the CUE language."

  ;; Comments
  (setq-local comment-start "// ")
  (setq-local comment-end "")
  (setq-local comment-start-skip "//[[:space:]]*")

  (setq indent-tabs-mode t)

  (setq-local font-lock-defaults '(cue--font-lock-keywords)))

;;;###autoload
(add-to-list 'auto-mode-alist '("\\.cue\\'" . cue-mode))
#+end_src

* TODO
- [ ] projectile terminal (gets or creates terminal at root of current project)
- [ ] default popup windows
- [ ] lsp-mode & cider-mode competition?
  - company backend (lsp seems completely disabled for this?)
  - eldoc stuffs they definitely compete
- [ ] company mode backend for text completion?
- [ ] move machine-specific setup into separate file so they don't have to keep changing
- [ ] clojure errors go to popwin
- [ ] keybindings
  - terminal
  - eval-previously-evaled-test
- [ ] auto right align for maps and lets (like how aggressive indent works)
- [ ] popup for cider errors instead of other window
- [ ] archive todo
  - would also like a popup to ask where to put it?
  - this could have much overlapping functionality with add-to-list
    which allows you insert an org-roam link and add that link to a
    list somewhere and then you put whatever at that link
- [ ] clojure errors go to popwin, no focus?
- [X] advice for dired, select file, do delete all dired buffers so back buffer works
- [X] eval-test-around-point
- [X] modify autoindent to be smarter! maybe use clj-kondo?
- [X] paredit
- [X] fix eval to comment
- [X] doom modeline
- [X] eval sexp around point
